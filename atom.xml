<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>景三的个人小站</title>
  
  <subtitle>景行行止, 三省吾身。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://relish.wang/"/>
  <updated>2021-01-03T07:01:09.060Z</updated>
  <id>https://relish.wang/</id>
  
  <author>
    <name>景三</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>梦幻开局2020新的挑战2021</title>
    <link href="https://relish.wang/posts/63321/"/>
    <id>https://relish.wang/posts/63321/</id>
    <published>2021-01-03T04:12:20.000Z</published>
    <updated>2021-01-03T07:01:09.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="梦幻开局2020新的挑战2021"><a href="#梦幻开局2020新的挑战2021" class="headerlink" title="梦幻开局2020新的挑战2021"></a>梦幻开局2020新的挑战2021</h1><p>[TOC]</p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>为什么是梦幻开局呢？因为新冠爆发了, 还记得我在<a href="https://relish.wang/posts/62750/">《2019就此告别2020新的征程》</a>里提到过:</p><p><img src="/posts/63321/2019ncov.png" alt></p><p>到了2020年初, 也就是2、3月份彻底爆发了。什么是梦幻开局？这才是梦幻开局。（战术后仰.gif）</p><a id="more"></a><h2 id="一、学习与工作"><a href="#一、学习与工作" class="headerlink" title="一、学习与工作"></a>一、学习与工作</h2><h3 id="①-工作变动"><a href="#①-工作变动" class="headerlink" title="① 工作变动"></a>① 工作变动</h3><p>2019年, <a href="https://ececloud.cn" target="_blank" rel="noopener">智晗</a>来了很多新的小伙伴, 也发生了很多人员和组织架构上的变动。(什么？这是2020年的年终总结, 为什么要说2019年？) 换了2个CTO, 又来了1个PMO，业务线又细分，但人力却不能很好地收敛，导致不少人在多条业务线上反复横跳。加之疫情的原因, 工作又是远程进行，信息沟通不及时，以及半吊子PMO欺上瞒下散布周六加班且包含加班工资的错误消息…总而言之, 就是多方原因导致了我萌生了跳槽的想法。</p><p>从第一场面试算起到最终确定Offer, 花了近一个月。其中也面试了一些其他知名的公司，有点不在状态，之前总想着先面试几家小公司找找感觉，后来发现战线拖得越长，后面越疲于应对。最佳的状态是开门见山，直捣黄龙。好在最后斩获了心仪的Offer, 最终来到了<a href="https://music.163.com" target="_blank" rel="noopener">网易云音乐</a>。</p><p><img src="/posts/63321/netease.JPG" alt></p><p>之前没在网上看到网易加班的负面新闻，尽管hr有提醒目前工作状态是995，但我仍以为并未如此夸张。后来证明我错了。网易云音乐8.0的开发任务，比想象中的还要繁重。与智晗的工作节奏对比之下，我一度觉得我亏了。好在8.0之后，恢复了较为稳健的迭代节奏。</p><p>不得不说云音乐的代码质量，确实比智晗高上不少；开发人员的科学素养也较以往经历过的公司好上不少。有非常多值得学习的地方，当然也有不足，取其精华去其糟粕嘛。不过云音乐的组件化进程确实有些慢，早在2017年大搜车就已经开始了组件化，但云音乐到2020年下半年才开始做这件事。</p><h3 id="②-血吼本体"><a href="#②-血吼本体" class="headerlink" title="② 血吼本体"></a>② 血吼本体</h3><p>在网易一期见到了血吼本体：</p><p><img src="/posts/63321/xuehou_lushi.JPG" alt></p><p><img src="/posts/63321/xuehou.JPG" alt></p><h3 id="③-干饭人不聊工作"><a href="#③-干饭人不聊工作" class="headerlink" title="③ 干饭人不聊工作"></a>③ 干饭人不聊工作</h3><p>结识了一群有趣的小伙伴。每天准时干饭; 日常吹逼; 周常开车(羽毛球、英雄联盟, 比较活跃的小伙伴还有其他活动，比如吃饭，唱k，滑雪)。非常欢乐。</p><h3 id="④-内推奖励"><a href="#④-内推奖励" class="headerlink" title="④ 内推奖励"></a>④ 内推奖励</h3><p>内推了一位小伙伴。拿到了伯乐奖￥3k+云音乐黑胶年费会员。</p><h2 id="二、生活与情感"><a href="#二、生活与情感" class="headerlink" title="二、生活与情感"></a>二、生活与情感</h2><h3 id="①-执子之手与子偕老"><a href="#①-执子之手与子偕老" class="headerlink" title="① 执子之手与子偕老"></a>① 执子之手与子偕老</h3><p>钟于意，衷于心，忠于一人，终于修成正果。</p><p><img src="/posts/63321/wedding.png" alt></p><p>为什么是儿童节领证？以后有了孩子，一家三口可以一起过节。:D</p><h3 id="②-龟鳖本一家"><a href="#②-龟鳖本一家" class="headerlink" title="② 龟鳖本一家"></a>② 龟鳖本一家</h3><p>放生了一只小乌龟。</p><p><img src="/posts/63321/guibie.JPG" alt></p><p>但甲鱼就没这么好运气了。<br><img src="/posts/63321/jiayu.png" alt></p><h3 id="③-疫情之下出游是真的难"><a href="#③-疫情之下出游是真的难" class="headerlink" title="③ 疫情之下出游是真的难"></a>③ 疫情之下出游是真的难</h3><h4 id="横店"><a href="#横店" class="headerlink" title="横店"></a>横店</h4><p>俊杰请客游横店。毕业多年没见了, 有点怀念以前的日子。</p><p><img src="/posts/63321/hengdian.JPG" alt></p><h4 id="龙之梦野生动物园"><a href="#龙之梦野生动物园" class="headerlink" title="龙之梦野生动物园"></a>龙之梦野生动物园</h4><p>就是逛的有点累。</p><h3 id="④-电子产品都是早买早享受"><a href="#④-电子产品都是早买早享受" class="headerlink" title="④ 电子产品都是早买早享受"></a>④ 电子产品都是早买早享受</h3><h4 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h4><p>买了人生的第一台主机电脑。10850k+3070TUF。</p><p><img src="/posts/63321/pc.png" alt></p><h4 id="iPhone-12"><a href="#iPhone-12" class="headerlink" title="iPhone 12"></a>iPhone 12</h4><p>买了人生的第一台iPhone。</p><h4 id="MacBook-Pro"><a href="#MacBook-Pro" class="headerlink" title="MacBook Pro"></a>MacBook Pro</h4><p>老婆入职新公司, 买了一台MBP。</p><h2 id="三、娱乐与消遣"><a href="#三、娱乐与消遣" class="headerlink" title="三、娱乐与消遣"></a>三、娱乐与消遣</h2><h3 id="1-动漫"><a href="#1-动漫" class="headerlink" title="1 动漫"></a>1 动漫</h3><p>去年提到的《我的英雄学院》突然被爆出辱华, 全网下架了。侮辱我们中华民族的狗东西, 滚粗。</p><p>JoJo第六部还是没出，就像给他爱六还没出。（都2020年了到底是谁还在买给她爱五?!）</p><h4 id="①-元龙"><a href="#①-元龙" class="headerlink" title="① 元龙"></a>① 元龙</h4><p>讲现代兵王穿越到异世界装逼的。有点上头。</p><h4 id="②-灵笼"><a href="#②-灵笼" class="headerlink" title="② 灵笼"></a>② 灵笼</h4><p>国漫之光啊! 必须吹爆! 据说2021年春季会出一集60分钟的超长大结局【灵笼-终章】。期待ing~</p><h4 id="③-JoJo的奇妙冒险"><a href="#③-JoJo的奇妙冒险" class="headerlink" title="③ JoJo的奇妙冒险"></a>③ JoJo的奇妙冒险</h4><p>陪老婆又看了一遍。还是精彩!!!</p><p><img src="/posts/63321/jojo.JPG" alt></p><h3 id="2-游戏"><a href="#2-游戏" class="headerlink" title="2 游戏"></a>2 游戏</h3><p><strong>Nintendo Switch</strong></p><h4 id="①-《塞尔达传说·旷野之息》"><a href="#①-《塞尔达传说·旷野之息》" class="headerlink" title="① 《塞尔达传说·旷野之息》"></a>① 《塞尔达传说·旷野之息》</h4><p>终于全神庙了。目前迷你任务88/90。呀哈哈还差的有点多。山神还没去看过。双弹击飞初有成效, 现在都不好好走路了。哈哈哈哈…坐等续作。</p><p><img src="/posts/63321/saierda.JPG" alt></p><h4 id="②-《塞尔达传说·灾厄启示录》"><a href="#②-《塞尔达传说·灾厄启示录》" class="headerlink" title="② 《塞尔达传说·灾厄启示录》"></a>② 《塞尔达传说·灾厄启示录》</h4><p>无双割草游戏。就当补补100年前的剧情了。小舅子是真的可爱~</p><p><img src="/posts/63321/xiaojiuzi.png" alt></p><h4 id="③-《集合吧-动物森友会》"><a href="#③-《集合吧-动物森友会》" class="headerlink" title="③ 《集合吧! 动物森友会》"></a>③ 《集合吧! 动物森友会》</h4><p>前期还挺好玩，后面发现东西堆的到处都是，又要整理，是真的费劲。钓鱼也钓不到好东西。开岛都是开到垃圾岛。大头菜也卖不出好价格。唉，弃坑了~</p><p><strong>炉石传说</strong></p><p>日常下棋。版本迭代了几波，有点不会玩了。任务系统也变样了，每次新赛季重置战旗积分, 还能不能好好玩了。最近潘sir在我号上做了一套奇迹换家德，还挺有意思。</p><p><strong>PC</strong></p><p>Epic送了不少游戏，但没啥好玩的。都是先领了再说。</p><h4 id="①-《赛博朋克2077》"><a href="#①-《赛博朋克2077》" class="headerlink" title="① 《赛博朋克2077》"></a>① 《赛博朋克2077》</h4><p>被CDPR骗了呀。在游戏中随处可见的未完成的痕迹。只能期待日后打补丁修复吧。</p><h4 id="②-《巫师3》"><a href="#②-《巫师3》" class="headerlink" title="② 《巫师3》"></a>② 《巫师3》</h4><p>先买了，还没玩。</p><h4 id="③-《人类一败涂地》"><a href="#③-《人类一败涂地》" class="headerlink" title="③ 《人类一败涂地》"></a>③ 《人类一败涂地》</h4><p>其实在Switch买了这个游戏了。最近又跟陈老师和阿帅一起玩了一下。玩了后面还没玩过的关卡，还是挺有意思的。</p><h4 id="④-《英雄联盟》"><a href="#④-《英雄联盟》" class="headerlink" title="④ 《英雄联盟》"></a>④ 《英雄联盟》</h4><p>和干饭群的同事们一起玩。日常拖后腿。</p><h2 id="四、总结与规划"><a href="#四、总结与规划" class="headerlink" title="四、总结与规划"></a>四、总结与规划</h2><p>一个目标也没完成。</p><p><img src="/posts/63321/xiaochou.png" alt></p><p>既然如此, 那就大胆点。2021年我要买房买车!</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;梦幻开局2020新的挑战2021&quot;&gt;&lt;a href=&quot;#梦幻开局2020新的挑战2021&quot; class=&quot;headerlink&quot; title=&quot;梦幻开局2020新的挑战2021&quot;&gt;&lt;/a&gt;梦幻开局2020新的挑战2021&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;为什么是梦幻开局呢？因为新冠爆发了, 还记得我在&lt;a href=&quot;https://relish.wang/posts/62750/&quot;&gt;《2019就此告别2020新的征程》&lt;/a&gt;里提到过:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/63321/2019ncov.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;到了2020年初, 也就是2、3月份彻底爆发了。什么是梦幻开局？这才是梦幻开局。（战术后仰.gif）&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="https://relish.wang/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://relish.wang/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ViewModel一个简单例子</title>
    <link href="https://relish.wang/posts/1/"/>
    <id>https://relish.wang/posts/1/</id>
    <published>2020-07-02T04:34:03.000Z</published>
    <updated>2020-07-02T07:55:21.670Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ViewModel-一个简单例子"><a href="#ViewModel-一个简单例子" class="headerlink" title="ViewModel: 一个简单例子"></a>ViewModel: 一个简单例子</h1><blockquote><p>原文地址:  <a href="https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e" target="_blank" rel="noopener">《ViewModels: A Simple Example》</a></p></blockquote><p>[TOC]</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>两年多前, 我从事一档被称为“Android for Beginners”的面向零编程基础的学生并引导他们建立自己的第一个Android应用程序的课程。作为课程的一部分, 学生们需要构建一个简单的单页面应用——《篮球计分器》。</p><p>《篮球计分器》是一个非常直观的App。它的按钮用于修改篮球队的得分。尽管最终完成的app有一个bug, 如果你旋转手机屏幕，你当前的分数就会莫名其妙地消失。</p><p><img src="/posts/1/rotate.gif" alt></p><a id="more"></a><p>发生了什么？旋转设备是应用在其生命周期内可以进行的一些配置更改之一，包括键盘可用性和更改设备语言。所有这些配置更改都会导致Activity被销毁并重新创建。</p><p>这种行为引导我们应当进行诸如在设备旋转时使用横向特定布局的操作。不幸的是，这对于新手(哪怕有时候并不是那么新手)的工程师来说可能是个头疼的问题。</p><p>在2017年的Google I/O大会上, Android框架团队推出了一套新的架构组件，其中一个组件可以解决这一确切的旋转问题。</p><p>ViewModel类旨在以生命周期感知的方式保存和管理与UI相关的数据。它使得数据可以在配置变更(比如屏幕旋转)的情况下存活。</p><p>这篇文章是探索ViewModel来龙去脉的系列文章的第一篇。在这篇文章中，我将:</p><ul><li>解释ViewModels实现的基本需求</li><li>使用ViewModel去改造《篮球计分器》的代码以解决旋转问题</li><li>深入了解ViewModel和UI组件的联系</li></ul><h2 id="潜在的问题"><a href="#潜在的问题" class="headerlink" title="潜在的问题"></a>潜在的问题</h2><p>现在存在一个潜在的挑战是: Android的Activity的生命周期有很多状态，并且由于配置更改，单个Activity可能会在这些不同状态之间循环多次。</p><p><img src="/posts/1/activity_lifecycle.png" alt></p><p>当一个Activity经历了所有这些状态，您可能还需要将瞬态UI数据保存在内存中。我将<strong>瞬态UI数据</strong>定义为UI所需的数据,包括用户输入的数据，运行时生成的数据或从数据库加载的数据。这些数据可以是图片位图、用于RecyclerView的对象列表等，在这个例子中是篮球队分数。</p><p>显然, 你也许使用了<a href="https://developer.android.com/reference/android/app/Activity.html#onRetainNonConfigurationInstance()" target="_blank" rel="noopener"><code>onRetainNonConfigurationInstance</code></a>在配置更改到重新加载它的期间保存<strong>瞬态UI数据</strong>。但是，如果您的数据不需要知道或管理<strong>Activity</strong>所处于的生命周期状态会不会隆起(swell)？与其在Activity内不声明像scoreTeamA这样的变量，而是异想天开地将其绑定到Activity生命周期，不如将这些数据存储在Activity之外的其他地方，该怎么办？<strong>这就是ViewModel类的目的。</strong></p><p>在下面的图表中, 你可以看到Activity的生命周期在旋转过程中的状态流转直到<code>finish</code>。ViewModel的生命周期显示在关联的Activity的生命周期的旁边。请注意，这个ViewModels可以简单轻松地与UI控制器(Activities/Fragments)结合使用。</p><p><img src="/posts/1/viewmodel_lifecycle.png" alt></p><p>ViewModel存在于你第一次请求一个ViewModel(通常在Activity的<code>onCreate</code>中)直到Activity已经finished或者destoryed期间。<code>onCreate</code>在Activity的一次声明中也许会被地调用多次，比如当app发生旋转时，但是ViewModel在此期间一直存活着。</p><h2 id="一个非常简单的例子"><a href="#一个非常简单的例子" class="headerlink" title="一个非常简单的例子"></a>一个非常简单的例子</h2><p>使用ViewModel的三个步骤：</p><ol><li>通过创建一个<strong>继承自ViewModel的类</strong>来从你的UI控制器(Activity或Fragment)中分离出你的ViewModel</li><li>在你的UI控制器和ViewModel之间<strong>建立通讯</strong></li><li>在你的UI控制器中<strong>使用ViewModel</strong></li></ol><h3 id="第一步：创建一个ViewModel类"><a href="#第一步：创建一个ViewModel类" class="headerlink" title="第一步：创建一个ViewModel类"></a>第一步：创建一个ViewModel类</h3><p><strong>注意</strong>：为了创建ViewModel类，你第一步需要添加正确的<code>lifecycle</code>依赖. 看<a href="https://developer.android.com/jetpack/androidx/releases/lifecycle#declaring_dependencies" target="_blank" rel="noopener">这里</a>如何做。</p><p>通常情况下，你需要为你的app的每隔页面创建一个ViewModel类。这个ViewModel类会掌控和管理所有的与页面相关数据，并且提供get/set方法用于存取数据。这会将显示Activity的UI代码与您的用于显示UI的数据分离开(显示UI的数据现在位于ViewModel中)。那么，让我们为《篮球计分器》的那个页面创建一个ViewModel类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Tracks the score for Team A</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> scoreTeamA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Tracks the score for Team B</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> scoreTeamB = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了简洁起见，我选择将数据作为公共成员存储在我的<code>ScoreViewModel.java</code>中，但是创建更好的封装getter和setter的方法是一个好主意。</p><h3 id="第二步：-关联UI控制器和ViewModel"><a href="#第二步：-关联UI控制器和ViewModel" class="headerlink" title="第二步： 关联UI控制器和ViewModel"></a>第二步： 关联UI控制器和ViewModel</h3><p>你的UI控制器(即Activity或Fragment)需要知道你的ViewModel。这样在诸如“在《篮球计分器》中按下按钮去增加某一队分数”等UI交互发生时, UI控制器可以展示和更新数据。</p><p><strong>但是，ViewModels不应保留对Activity，Fragment或Context的引用。</strong>此外，ViewModels不应包含那些拥有对UI控制器的引用的元素，例如Views，因为这将创建对Context的间接引用。</p><p>你不该保存这些对象的原因是, ViewModels的寿命超出了特定的UI控制实例之外——如果您将Activity旋转3次，则您刚刚创建了三个不同的Activity实例，但是只有一个ViewModel实例。</p><p>考虑到这一点，让我们来创建这个UI控制器/ViewModel关联。你想要为在UI控制器中的ViewModel创建一个成员变量。那么在<code>onCreate</code>中，你应该这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModelProviders.of(&lt;Your UI controller&gt;).get(&lt;Your ViewModel&gt;.class)</span><br></pre></td></tr></table></figure><p>对于《篮球计分器》，它应该像这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">   setContentView(R.layout.activity_main);</span><br><span class="line">   mViewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(ScoreViewModel.class);</span><br><span class="line">   <span class="comment">// Other setup code below...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> “ViewModel中没有上下文”的规则有一个例外: 有时您可能需要一个Application的Context(而不是Activity的Context)来与诸如系统服务之类的东西一起使用。那么，您可以将应用程序上下文储存在ViewModel中，因为应用程序上下文与应用程序生命周期相关联。这不同于与Activity生命周期相关的Activity的Context。实际上如果需要Application的Context，则应该拓展<code>AndroidViewModel</code>,它只是一个包含Application引用的ViewModel。</p><h3 id="第三步-在你的UI控制器中使用ViewModel"><a href="#第三步-在你的UI控制器中使用ViewModel" class="headerlink" title="第三步: 在你的UI控制器中使用ViewModel"></a>第三步: 在你的UI控制器中使用ViewModel</h3><p>为了访问和修改UI数据，你现在可以在你的ViewModel中使用数据。这里有一个新的<code>onCreate</code>方法和一个为队伍A增加分数的更新方法的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The finished onCreate method</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">   setContentView(R.layout.activity_main);</span><br><span class="line">   mViewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(ScoreViewModel.class);</span><br><span class="line">   displayForTeamA(mViewModel.scoreTeamA);</span><br><span class="line">   displayForTeamB(mViewModel.scoreTeamB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An example of both reading and writing to the ViewModel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOneForTeamA</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">   mViewModel.scoreTeamA = mViewModel.scoreTeamA + <span class="number">1</span>;</span><br><span class="line">   displayForTeamA(mViewModel.scoreTeamA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>专业意见：</strong> ViewModel也可以很好地和其他架构组件一起工作。比如: LiveData, 这我就不再这篇文章中拓展了。使用LiveData的另一个好处是它可以观察到：当数据更改时，它可以触发UI更新。您可以在<a href="https://developer.android.com/topic/libraries/architecture/livedata.html" target="_blank" rel="noopener">此处</a>了解有关LiveData的更多信息。</p><h2 id="对ViewModelsProviders-of的更深入了解"><a href="#对ViewModelsProviders-of的更深入了解" class="headerlink" title="对ViewModelsProviders.of的更深入了解"></a>对<code>ViewModelsProviders.of</code>的更深入了解</h2><p>在MainActivity中第一次调用<code>ViewModelsProviders.of</code>方法时，一个ViewModel实例就创建完成了。当这个方法再次被调用时(即<code>onCreate</code>方法被再次调用)，它会返回一个与确切的《篮球计分器》的MainActivity相关联的预先存在的ViewModel。这就是保存数据的原因。</p><p>仅当您传入正确的UI控制器作为第一个参数时, 此方法才有效。尽管你永远不应将UI控制器储存在ViewModel内，但ViewModel类确实会使用您传入的第一个参数(UI控制器)来跟踪ViewModel和UI控制器实力在后台之间的关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModelProviders.of(&lt;THIS ARGUMENT&gt;).get(ScoreViewModel.class);</span><br></pre></td></tr></table></figure><p>这使得您的app可以打开很多不同的Activity/Fragment实例，但是持有不同的ViewModel内容。让我们想象一下，如果我们拓展我们的《篮球计分器》例子——可以记录多场篮球赛的比分。所有的比赛都展示在一个列表页。点击列表中的其中一个比赛，就会打开一个像我们当前的MainActivity的页面，我们可以将它称作<code>GameScoreActivity</code>。</p><p>为了你所打开的每场不同的比赛的积分页面，你可以在<code>OnCreate</code>中关联<code>GameScoreActivity</code>和ViewModel, 这样就会创建不同的ViewModel实例。如果你旋转了其中一个屏幕，那么与相同的ViewModel的关联关系会被保存下来。</p><p><img src="/posts/1/multi_game.png" alt></p><p>通过调用<code>ViewModelProviders.of(&lt;Your UI controller&gt;).get(&lt;Your ViewModel&gt;.class)</code>所有的这些逻辑都为你完成了。所以只要你传递了正确的UI控制器实例(<code>Your UI controller</code>)，它就起作用了。</p><p><strong>最后的思考:</strong> ViewModels十分巧妙地分离了用于展示UI的数据和UI控制器的代码。它们不能完全解决数据持久性和保存应用程序状态的问题。在下一篇文章里, 我会探索Activity生命周期与ViewModels的微妙交互，以及ViewModels与<code>onSaveInstanceState</code>的比较。</p><h2 id="结论和进一步学习"><a href="#结论和进一步学习" class="headerlink" title="结论和进一步学习"></a>结论和进一步学习</h2><p>在这篇文章里吗，我探索了ViewModel类的最基础用法。关键要点是:</p><ul><li>ViewModel类旨在以生命周期感知的方式保存和管理与UI相关的数据。这使数据能够承受配置更改（例如屏幕旋转）的影响。</li><li>ViewModels将UI实施与应用数据分开。</li><li>通常，如果您应用中的屏幕上有临时数据，则应为该屏幕上的数据创建一个单独的ViewModel。ViewModel的生命周期从首次创建关联的UI控制器开始，一直到完全销毁为止。</li><li>切勿将UI控制器或Context直接或间接存储在ViewModel中。这包括将View存储在ViewModel中。直接或间接引用UI控制器会破坏将UI与数据分离的目的，并可能导致内存泄漏。</li><li>ViewModel对象通常会存储LiveData对象，您可以在<a href="https://developer.android.com/topic/libraries/architecture/livedata.html" target="_blank" rel="noopener">此处</a>了解更多信息。</li><li><code>ViewModelProviders.of</code>方法跟踪通过作为参数传入的UI控制器与ViewModel关联的UI控制器。</li></ul><p>想要了解更多ViewModel化的优势吗？请查阅:</p><ul><li><a href="https://developer.android.com/topic/libraries/architecture/adding-components.html" target="_blank" rel="noopener">《Instructions for adding the gradle dependencies》</a></li><li><a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank" rel="noopener">ViewModel</a> documentation</li><li>Guided ViewModel practice with the <a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view/" target="_blank" rel="noopener">Room with a View</a> and <a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#0" target="_blank" rel="noopener">Lifecycles Codelab</a></li></ul><p>架构组件的创建给予你们的反馈。如果您有什么问题和意见关于ViewModel或者任何其他的架构组件，请查看我们的<a href="https://developer.android.com/topic/libraries/architecture/feedback.html" target="_blank" rel="noopener">意见反馈页面</a>。有任何问题关于此系列文章吗？留下评论吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ViewModel-一个简单例子&quot;&gt;&lt;a href=&quot;#ViewModel-一个简单例子&quot; class=&quot;headerlink&quot; title=&quot;ViewModel: 一个简单例子&quot;&gt;&lt;/a&gt;ViewModel: 一个简单例子&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址:  &lt;a href=&quot;https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《ViewModels: A Simple Example》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;两年多前, 我从事一档被称为“Android for Beginners”的面向零编程基础的学生并引导他们建立自己的第一个Android应用程序的课程。作为课程的一部分, 学生们需要构建一个简单的单页面应用——《篮球计分器》。&lt;/p&gt;
&lt;p&gt;《篮球计分器》是一个非常直观的App。它的按钮用于修改篮球队的得分。尽管最终完成的app有一个bug, 如果你旋转手机屏幕，你当前的分数就会莫名其妙地消失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/1/rotate.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JetPack" scheme="https://relish.wang/categories/JetPack/"/>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="JetPack" scheme="https://relish.wang/tags/JetPack/"/>
    
  </entry>
  
  <entry>
    <title>使用WorkManager来处理后台任务(Kotlin版)(一)</title>
    <link href="https://relish.wang/posts/960/"/>
    <id>https://relish.wang/posts/960/</id>
    <published>2020-07-02T04:34:03.000Z</published>
    <updated>2020-07-02T07:55:21.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用WorkManager来处理后台任务-Kotlin版-一"><a href="#使用WorkManager来处理后台任务-Kotlin版-一" class="headerlink" title="使用WorkManager来处理后台任务(Kotlin版)(一)"></a>使用WorkManager来处理后台任务(Kotlin版)(一)</h1><blockquote><p>原文地址: <a href="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/#0" target="_blank" rel="noopener">《Background Work with WorkManager - Kotlin》</a></p></blockquote><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>在Android开发中有很多用于处理延迟处理的后台任务的方式。这个<em>代码实验室</em>(codelab)涵盖了<em>WorkManager</em>(一个向后兼容的、灵活的、简单易用的、用于延迟处理后台任务的<em>代码库</em>(library))的用法。</p><a id="more"></a><h3 id="什么是WorkManager"><a href="#什么是WorkManager" class="headerlink" title="什么是WorkManager"></a>什么是WorkManager</h3><p>WorkManager是Android JetPack的一部分，是结合了机会性执行和保证执行的的用于处理后台任务的<em>架构组件</em>（Architecture Component）。机会性执行，意为WorkManager将尽快完成您的后台工作。保证执行，意为无论在什么样的情况下,即使用户离开了应用程序, WorkManager也会保证按逻辑执行工作。</p><p>WorkManager是一个难以置信的、灵活的代码库，它拥有很多额外的优势。比如:</p><ul><li>调度一次性或周期性异步任务</li><li>支持网络条件，存储空间和充电状态等约束</li><li>将任务链接起来，包括并行运行的任务</li><li>一个任务的输出结果用于另一个任务的输入参数</li><li>向后兼容到API 14</li><li>使不使用Google Play服务都可以</li><li>遵循系统健康最佳实践</li><li>配合LiveData可以轻松在UI中显示工作的请求状态</li></ul><blockquote><p>注意:</p><p>WorkManager提供了一些API。例如: JobSCheduler和AlarmManager。WorkManager根据诸如用户设备API之类的条件选择要使用的正确API。欲了解更多信息，请查阅<a href="https://developer.android.com/topic/libraries/architecture/workmanager/" target="_blank" rel="noopener">WorkManager文档</a>。</p></blockquote><h3 id="什么时候使用WorkManager"><a href="#什么时候使用WorkManager" class="headerlink" title="什么时候使用WorkManager"></a>什么时候使用WorkManager</h3><p>对于即使用户离开特定的屏幕或您的应用程序也需要完成的有价值的任务，WorkManager库也是个不错的选择。</p><p>以下是使用WorkManager的几个简单例子:</p><ul><li>上传日志</li><li>用于过滤图片和保存图片</li><li>定期将本地数据与网络同步</li></ul><p>WorkManager提供有保证的执行，但并非所有任务都需要执行。因此，这不是将所有任务避免在主线程中运行的万能方法。</p><p>有关何时使用WorkManager的更多详细信息，请查阅<a href="https://developer.android.com/guide/background/" target="_blank" rel="noopener">《后台处理指南》</a>。</p><h3 id="你会建立什么"><a href="#你会建立什么" class="headerlink" title="你会建立什么"></a>你会建立什么</h3><p>近些年来，智能手机越来越擅长拍照。摄影师能够可靠地模糊拍摄神秘事物的日子已经一去不复返了。在此代码实验室中，您将使用Blur-O-Matic，该应用程序可模糊照片和图像并将结果保存到文件中。那是尼斯湖怪兽或evelopera玩具潜水艇吗？使用Blur-O-Matic，没人会知道。</p><p><img src="/posts/960/clear.png" alt> <img src="/posts/960/blurry.png" alt></p><h3 id="你会学到什么"><a href="#你会学到什么" class="headerlink" title="你会学到什么"></a>你会学到什么</h3><ul><li><p>在你的项目中使用WorkManager</p></li><li><p>安排一个简单的任务</p></li><li><p>输入和输出参数</p></li><li><p>串行的任务</p></li><li><p>独特的任务</p></li><li><p>将任务状态展示在UI上</p></li><li><p>取消任务</p></li><li><p>任务约束</p></li></ul><h3 id="你需要什么"><a href="#你需要什么" class="headerlink" title="你需要什么"></a>你需要什么</h3><ul><li>最新稳定版Android Studio</li><li>你需要熟悉LiveData和ViewModel。如果你对这些类还不够熟悉，查阅<a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#0" target="_blank" rel="noopener">《Android生命周期感知组件Codelab》</a>(专门介绍LiveData和ViewModel)或者<a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view/#0" target="_blank" rel="noopener">《Room和View》</a>（架构组件(Architecture Components)的介绍）</li></ul><h3 id="如何你在任何地方卡关了"><a href="#如何你在任何地方卡关了" class="headerlink" title="如何你在任何地方卡关了"></a>如何你在任何地方卡关了</h3><p>如果你卡关了，如果你需要查看最终状态的代码，你可以使用下面的代码链接:</p><p><a href="https://github.com/googlecodelabs/android-workmanager/archive/kotlin.zip" target="_blank" rel="noopener">下载最终代码</a></p><p>或者, 如果你更希望从Github克隆完整的WorkManager的代码实验室的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b kotlin https://github.com/googlecodelabs/android-workmanager</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用WorkManager来处理后台任务-Kotlin版-一&quot;&gt;&lt;a href=&quot;#使用WorkManager来处理后台任务-Kotlin版-一&quot; class=&quot;headerlink&quot; title=&quot;使用WorkManager来处理后台任务(Kotlin版)(一)&quot;&gt;&lt;/a&gt;使用WorkManager来处理后台任务(Kotlin版)(一)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-workmanager-kt/#0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Background Work with WorkManager - Kotlin》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h2&gt;&lt;p&gt;在Android开发中有很多用于处理延迟处理的后台任务的方式。这个&lt;em&gt;代码实验室&lt;/em&gt;(codelab)涵盖了&lt;em&gt;WorkManager&lt;/em&gt;(一个向后兼容的、灵活的、简单易用的、用于延迟处理后台任务的&lt;em&gt;代码库&lt;/em&gt;(library))的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="JetPack" scheme="https://relish.wang/categories/JetPack/"/>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="JetPack" scheme="https://relish.wang/tags/JetPack/"/>
    
  </entry>
  
  <entry>
    <title>2019就此告别2020新的征程</title>
    <link href="https://relish.wang/posts/62750/"/>
    <id>https://relish.wang/posts/62750/</id>
    <published>2020-01-19T02:04:37.000Z</published>
    <updated>2020-01-21T09:51:43.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2019就此告别2020新的征程"><a href="#2019就此告别2020新的征程" class="headerlink" title="2019就此告别2020新的征程"></a>2019就此告别2020新的征程</h1><p>[TOC]</p><h2 id="一、学习与工作"><a href="#一、学习与工作" class="headerlink" title="一、学习与工作"></a>一、学习与工作</h2><p>2019年年初阔别了工作两年的<a href="https://www.dasouche.com/zh/" target="_blank" rel="noopener"><em>大搜车</em></a>，满怀新鲜感来到了<a href="https://ececloud.cn" target="_blank" rel="noopener"><em>学智云</em></a>。至此开启了我的梦幻2019年。</p><a id="more"></a><h3 id="1-梦幻开局·工程结构改造"><a href="#1-梦幻开局·工程结构改造" class="headerlink" title="1 梦幻开局·工程结构改造"></a>1 梦幻开局·<strong>工程结构改造</strong></h3><p>初到公司接触的第一个工程就是学智云Android主工程。初见之时真是说不出的梦幻感。</p><ul><li>1 模块间使用<strong>本地相对路径依赖</strong>(导致模块间的git节点间毫无联系, <strong>代码难回溯</strong>)</li><li>2 Git仓库<strong>多了一层路径</strong>(比如项目名叫<code>xuezhi</code>, 它的根目录是<code>xuezhi/xuezhi</code>，再往里面才是<code>build.gradle</code>、<code>setting.gradle</code>等工程代码文件)</li><li>3 项目中文件、代码的<strong>命名</strong>也相当<strong>混乱</strong>, 甚至有整个java/xml文件全被<strong>注释</strong>的，却<strong>不删掉</strong>，还是留在项目中</li><li>4 只能提交主工程的代码, 子模块的代码要到各自的git本地仓库中提交</li><li>5 其他<strong>工程结构引起的问题</strong></li></ul><p><img src="/posts/62750/xuezhi_project_stuct.png" alt></p><p>鉴于这些存在的问题，我进入公司的第一件事便是，对其进行工程结构改造。首要解决的问题是<strong>代码回溯</strong>问题。</p><h4 id="①-过渡方案-git-submodule"><a href="#①-过渡方案-git-submodule" class="headerlink" title="① 过渡方案(git submodule)"></a>① 过渡方案(git submodule)</h4><p>改造之前稍微解释一下<strong>本地相对路径依赖</strong>。</p><p><strong>改造前</strong>目录结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">|--xuezhi(学智云Android主工程Git仓库)</span><br><span class="line">||-- xuezhi(主工程)</span><br><span class="line">|||-- module.depend(子模块依赖路径配置文件)</span><br><span class="line">|||-- app(主模块)</span><br><span class="line">|||-- build.gradle</span><br><span class="line">|||-- setting.gradle</span><br><span class="line">|||-- ...(其他工程文件)</span><br><span class="line">|--bizcomp(业务模块)</span><br><span class="line">|-- AndroidLearnCenter(学习中心Git仓库)</span><br><span class="line">||-- learncenter(学习中心模块-被app依赖)</span><br><span class="line">|-- AndroidTeachCenter(教学中心Git仓库)</span><br><span class="line">      ||-- teachcenter(教学中心模块-被app依赖)</span><br><span class="line">|-- Android...Center(其他业务模块Git仓库)</span><br><span class="line">      ||-- ...(其他业务模块-被app依赖)</span><br></pre></td></tr></table></figure><p>其中<code>module.depend</code>配置文件代码片段:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - <span class="comment"># 开头为注释</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 模块必须以module开头</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 另起一行 模块名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 另起一行 模块文件路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 另起一行 模块git根目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 另起一行 使用的分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> - 其他均会出错</span></span><br><span class="line">module</span><br><span class="line">    app-old</span><br><span class="line">        app-old</span><br><span class="line">        ../</span><br><span class="line">module</span><br><span class="line">    learncenter</span><br><span class="line">    ../../../bizcomp/AndroidLearnCenter/learncenter</span><br><span class="line">module</span><br><span class="line">    teachcenter</span><br><span class="line">    ../../../bizcomp/AndroidTeachCenter/teachcenter</span><br><span class="line"><span class="meta">#</span><span class="bash"> 省略部分代码</span></span><br></pre></td></tr></table></figure><p>然后在<code>setting.gradle</code>中遍历<code>module.depend</code>中的文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略解析配置文件的代码</span></span><br><span class="line"><span class="keyword">for</span>(module <span class="keyword">in</span> dependModules)&#123;</span><br><span class="line">include(<span class="string">"$&#123;module.name&#125;"</span>)</span><br><span class="line">  project(<span class="string">":$&#123;module.name&#125;"</span>).projectDir = file(<span class="string">"$&#123;module.path&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工程结构的问题很明显了，除了我说的<strong>难回溯</strong>的问题外，还有<strong>配置麻烦</strong>的问题。对于多人协作的项目而言, 增加和删除新的业务模块都需要每个人本地的子模块的本地路径保持一致。这个问题不复杂但是麻烦。哪有别人改了代码后我拉去了远程代码还不行, 还跟学他的本地路径配置？! 这工程结构是真的有够反人类的。回归主题，那么这个工程结构为什么会有难回溯的问题呢？我来描述一个场景。主工程和业务模块都在各自提交代码,  但是比如app发布1.0版本，此时主工程知道自己在哪个git节点，也知道各自的业务模块在哪个git节点。但是当我发布2.0版本的时候，还知道各自的业务模块在发布1.0的时候是哪个git节点吗？显然是不能的。因为业务模块的git节点与主工程之间没有任何的git约束，仅仅通过源码依赖而已。甚至于你想回到1.0的发布版本重新打1.0包都有可能运行不起来(要是找不到正确的节点的话)。只有找对了所有业务模块在app发布1.0时的各自的git节点，才能完全还原1.0的包。费劲不？我甚至不知道这样的工程结构怎么根据线上bug日志排查问题…</p><p>此时<code>git submodule</code>的工程结构方案应运而生。它保留了原来的工程目录结构,对工程的破坏性小, 同时又加强了主/子工程之间的git节点联系。</p><p><strong>什么是<code>git submodule</code>?</strong></p><blockquote><p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p></blockquote><p>使用了<code>git submodule</code>的工程下会生成一个<code>.gitmodules</code>文件, 文件内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[submodule "submodules/AndroidLearnCenter"]</span><br><span class="line">path = submodules/AndroidLearnCenter</span><br><span class="line">url = https://git.xxx.com/xxx/AndroidLearnCenter.git</span><br><span class="line">branch = master</span><br><span class="line">[submodule "submodules/AndroidTeachCenter"]</span><br><span class="line">path = submodules/AndroidTeachCenter</span><br><span class="line">url = https://git.xxx.com/xxx/AndroidTeachCenter.git</span><br><span class="line">branch = master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 省略其他模块的配置</span></span><br></pre></td></tr></table></figure><p><strong>改造后</strong>的项目的目录结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|--xuezhi(学智云Android主工程Git仓库)</span><br><span class="line"> |-- submodules</span><br><span class="line"> |     |-- AndroidLearnCenter(学习中心Git仓库)</span><br><span class="line"> |     ||-- learncenter(学习中心模块-被app依赖)</span><br><span class="line"> |     |-- AndroidTeachCenter(教学中心Git仓库)</span><br><span class="line"> |     ||-- teachcenter(教学中心模块-被app依赖)</span><br><span class="line"> |     |-- Android...Center(其他业务模块Git仓库)</span><br><span class="line"> |     ||-- ...(其他业务模块-被app依赖)</span><br><span class="line"> |-- .gitmodules(子模块仓库配置文件)</span><br><span class="line"> |-- learncenter(软引用, 指向./submodules/AndroidLearnCenter/learncenter)</span><br><span class="line"> |-- teachcenter(软引用, 指向./submodules/AndroidTeachCenter/teachcenter)</span><br><span class="line"> |-- ...center(软引用, 指向./submodules/Android...Center/...)</span><br><span class="line"> |-- app(主模块)</span><br><span class="line"> |-- build.gradle</span><br><span class="line"> |-- setting.gradle</span><br><span class="line"> |-- ...(其他工程文件)</span><br></pre></td></tr></table></figure><p><code>setting.gradle</code>中的代码也更改为:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主工程</span></span><br><span class="line">include <span class="string">':app'</span></span><br><span class="line"><span class="comment">// 所有submodule依赖, 详情请查看.gitmodule文件</span></span><br><span class="line"><span class="keyword">new</span> File(<span class="string">'./'</span>).eachFile &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSymlink(it)) &#123; <span class="comment">// 自定义函数, 用于判断当前文件是否是软引用文件</span></span><br><span class="line">        include(<span class="string">":$&#123;it.getName()&#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成改造后, 每个子模块的git记录都可以查看，也可以提交到子模块的仓库，再也不需要打开多个AndroidStudio了。</p><p><img src="/posts/62750/multi_git_repo.png" alt></p><h4 id="②-maven私服-坐标依赖"><a href="#②-maven私服-坐标依赖" class="headerlink" title="② maven私服+坐标依赖"></a>② maven私服+坐标依赖</h4><p>maven私服+坐标依赖是目前的主流做法。私服其实早有搭建, 但疏于使用。在工程结构的规范化进程推动下，后期我们慢慢地将多个业务稳定的模块拆分, 打包上传到maven私服。经过几个月的努力, 所有的业务模块全都上传到了maven。git submodule结构也已经彻底移除。但在工程结构改造的路上, git submodule功不可没。</p><h3 id="2-新技能GET·Kotlin"><a href="#2-新技能GET·Kotlin" class="headerlink" title="2 新技能GET·Kotlin"></a>2 新技能GET·<strong>Kotlin</strong></h3><p>其实在2018年我已经使用了一段时间的Kotlin, 但并没有用于商业级项目中，只是偶尔耍耍题，小打小闹罢了。顺便给我们的仓库打个广告:  <a href="https://richcodersandme.github.io/LeetCode-Solution/" target="_blank" rel="noopener">RichCodersAndMe/LeetCode-Solution</a><br><img src="/posts/62750/leetcode_solution.png" alt></p><p>自从Google在2017年的Google I/O大会上宣布<code>Kotlin</code>成为Android 开发的一级(first-class)编程语言后，Kotlin在社区的影响力和发展稳步上升;而后又在2019年的Google I/O大会上宣布, Android 团队将会优先提供 Kotlin 版本的 Jetpack(Kotlin first)。官方如此尽力地推广, 我们开发者还有什么理由拒绝呢？ </p><p>但是商业级项目，以稳定为主，团队成员对Kotlin的掌握程度参差不齐，难免出现很多问题。那么如何优雅地过渡这个阶段，以推动Kotlin在自己团队内使用呢？</p><h4 id="①-悬浮窗开发调试工具-Genos"><a href="#①-悬浮窗开发调试工具-Genos" class="headerlink" title="① 悬浮窗开发调试工具(Genos)"></a>① 悬浮窗开发调试工具(Genos)</h4><p>悬浮窗开发调试工具应运而生。现已开源: <a href="https://github.com/relish-wang/genos" target="_blank" rel="noopener">relish-wang/genos</a>。</p><p><img src="/posts/62750/genos.png" alt></p><p>由于开发调试工具仅用于开发测试环境, 并不会运用于线上, 所以可以放心地使用Kotlin开发各种各样的插件;同时各种各样的功能强大的插件也极大地提高了我们开发和调试的效率。真可谓是一举两得！秒啊！</p><h4 id="②-纯Kotlin项目与编程思维转变"><a href="#②-纯Kotlin项目与编程思维转变" class="headerlink" title="② 纯Kotlin项目与编程思维转变"></a>② 纯Kotlin项目与编程思维转变</h4><p>随着对Kotlin的熟悉, 越来越感受到Kotlin为我们的工作带来的效率提升以及它优良的语法设计带来的舒适的编码体验，我们开始尝试在实际项目中使用Kotlin。恰好有一个新的XX云App的开发需求,  我迎难而上接下这个开发任务, 并全程使用Kotlin编写这个App。下图是截止到现在的XX云App的Kotlin语言在工程中所占的比例:</p><p><img src="/posts/62750/almost_kotlin.png" alt></p><p>在实际开发中其实有很多“水土不服”, 这些“水土不服”都源于我们长期对Java语言的使用而带来的惯性思维。举几个简单的例子:</p><ul><li>1 Kotlin的<a href="https://www.kotlincn.net/docs/reference/whatsnew11.html#alsotakeif-%E5%92%8C-takeunless" target="_blank" rel="noopener"><code>takeIf</code></a>这个<em>通用拓展函数</em>配合<em>安全调用操作符</em><a href="https://www.kotlincn.net/docs/reference/null-safety.html#%E5%AE%89%E5%85%A8%E7%9A%84%E8%B0%83%E7%94%A8" target="_blank" rel="noopener"><code>?.</code></a>的使用</li></ul><p>Java写法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj.someCondition())&#123; </span><br><span class="line">obj.doSomeThing(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是你仍然保持着Java的写法, 那这段代码转成Kotlin应该是这样:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj?.someCondition() == <span class="literal">true</span>)&#123;</span><br><span class="line">obj.doSomeThing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用上<code>takeIf</code>函数, 这段代码应该写成:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj?.takeIf&#123; it.someCondition() &#125;?.doSomeThing()</span><br></pre></td></tr></table></figure><p>条件判断语句写成了一行代码的链式的调用形式。代码简短, 逻辑清晰明了。</p><ul><li>2 数据类(<a href="https://www.kotlincn.net/docs/reference/data-classes.html#%E6%95%B0%E6%8D%AE%E7%B1%BB" target="_blank" rel="noopener"><code>data</code></a>)</li></ul><p>我们在Java中写一个<code>DTO</code>的话应该是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">long</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你仍然保持着Java的写法, 那这段代码转成Kotlin应该是这样:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">constructor</span>(id: <span class="built_in">Long</span>, name: String?, age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果你用上数据类(<a href="https://www.kotlincn.net/docs/reference/data-classes.html#%E6%95%B0%E6%8D%AE%E7%B1%BB" target="_blank" rel="noopener"><code>data</code></a>), 那应该写成这样:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> name: String? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>成员属性声明为<code>val</code>, 则对于Java调用来说只有<code>get</code>方法, 声明为<code>var</code>则有<code>get</code>和<code>set</code>方法。</p><ul><li>3 自定义<em>扩展函数</em></li></ul><p>相比很多的工程中都有类似这样的工具方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DisplayUtils.dp2px(Context context, <span class="keyword">int</span> dp)</span><br></pre></td></tr></table></figure><p>每次调用的时候都要传入<code>context</code>和具体数值。Kotlin的<em>扩展函数</em>为这种代码提供了更加舒适的语法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 声明扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">dp2px</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> reSize: <span class="built_in">Float</span> = Utils.getContext().resources.displayMetrics.density</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> * reSize + <span class="number">0.5</span>).toInt()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 调用扩展函数</span></span><br><span class="line">button.minimumHeight = <span class="number">16.</span>dp2px()</span><br><span class="line">layoutParams.height = statusBar.height.dp2px()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再举个例子:</span></span><br><span class="line"><span class="comment">// View单击事件(拦截了快速多次点击)</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> View.<span class="title">setOnSingleClickListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">crossinline</span> onClick: (<span class="type">View</span>)</span></span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">this</span>.isClickable = <span class="literal">false</span></span><br><span class="line">        onClick(it)</span><br><span class="line">        <span class="keyword">this</span>.postDelayed(&#123; <span class="keyword">this</span>.isClickable = <span class="literal">true</span> &#125;, <span class="number">800</span>L)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用setOnSingleClickListener</span></span><br><span class="line">btnLogin.setOnSingleClickListener &#123; <span class="comment">/* do sth.(默认入参it是onClick的View) */</span> &#125;</span><br></pre></td></tr></table></figure><p>Kotlin还有很多与Java的不同的语法习惯和编程思想:</p><ul><li>字符串内插</li><li>单表达式函数</li><li>对一个对象调用多个方法(<code>with</code>/<code>apply</code>)</li><li>函数的默认参数</li><li>…</li></ul><p>更多的<a href="https://www.kotlincn.net/docs/reference/idioms.html" target="_blank" rel="noopener">Kotlin习惯用法</a>&lt;-点这里</p><h4 id="③-Kotlin协程-Coroutines"><a href="#③-Kotlin协程-Coroutines" class="headerlink" title="③ Kotlin协程(Coroutines)"></a>③ Kotlin协程(<a href="https://www.kotlincn.net/docs/reference/coroutines-overview.html" target="_blank" rel="noopener"><code>Coroutines</code></a>)</h4><p>在XX云需求完成后，我转而负责学智云App的开发。有了在XX云中使用Kotlin的经验,  这次在学智云中我更加大胆地引入了Kotlin炙手可热的协程库(Coroutines).</p><p>为了体现<code>Coroutines</code>的语法优势这里我用<code>Retrofit+RxJava</code>和<code>Retrofit+Coroutines</code>做对比:</p><ul><li>1 <strong>串行执行</strong>两个网络请求:</li></ul><p>判断<strong>课程是否可用</strong>, 可用的情况下拉去课程的<strong>讲师列表</strong>，并展示</p><p><code>Retrofit+RxJava</code>:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 根据课程ID判断课程是否可用</span></span><br><span class="line">CourseApi.isCourseAvaliable(courseId) </span><br><span class="line">  .subscribeOn(Schedulers.io())</span><br><span class="line">  .flatMap(<span class="keyword">new</span> Function&lt;StdRespnose&lt;Void&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ObservableSource&lt;?&gt; apply(StdRespnose&lt;Void&gt; response) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(response.isSuccess())&#123;</span><br><span class="line">            <span class="comment">// 2.1 如果课程可用，则返回讲师列表</span></span><br><span class="line">      <span class="keyword">return</span> CourseApi.getLecturerList(courseId);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 2.2 如果课程不可用，则返回空的讲师列表</span></span><br><span class="line">          <span class="keyword">return</span> Obseravle.just(Collections.&lt;LecturerVO&gt;emptyList())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">  .as(AutoDispose.autoDisposable(AndroidLifecycleScopeProvider.from(<span class="keyword">this</span>)))</span><br><span class="line">  .subscribe(<span class="keyword">new</span> ObserverAdapter&lt;List&lt;LecturerVO&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;LecturerVO&gt; lecturerVOS)</span> </span>&#123;</span><br><span class="line"><span class="comment">// show lecturers</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>Retrofit+Coroutines</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rxjava2不允许传递null对象, 但Kotlin Coroutines可以直接在异常处退出(就像写同步代码一样)。因此两段代码的逻辑稍有不同。</span></span><br><span class="line">lifecycleScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">   <span class="comment">// 1 根据课程ID判断课程是否可用</span></span><br><span class="line">  <span class="keyword">val</span> isAvaliable:<span class="built_in">Boolean</span> = CourseApi.isCourseAvaliableKt(courseId)</span><br><span class="line">  ?.body()?.<span class="keyword">data</span>?.isAvaliable?:<span class="keyword">return</span><span class="symbol">@launch</span></span><br><span class="line"><span class="keyword">val</span> lecturerList :List&lt;LecturerVO&gt; = takeIf&#123; isAvaliable &#125;?.apply&#123;    </span><br><span class="line">        <span class="comment">// 2.1 如果课程可用，则返回讲师列表</span></span><br><span class="line">      CourseApi.getLecturerListKt(courseId)</span><br><span class="line">&#125; ?: emptyList() <span class="comment">// 2.2 如果课程不可用，则返回空的讲师列表</span></span><br><span class="line">  <span class="comment">//3 show lecturers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2 接收DTO转化为VO</li></ul><p><strong>拉取讲师列表</strong>, 将服务端返回的<strong>DTO转化为VO</strong>进行展示</p><p><code>Retrofit+RxJava</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CourseApi.getLecturerList(courseId)</span><br><span class="line">  .subscribeOn(Schedulers.io())</span><br><span class="line">  <span class="comment">// 将网络请求传递过来的源数据转化为直接交给UI层展示的数据</span></span><br><span class="line"> .map(<span class="keyword">new</span> Function&lt;StdListResponse&lt;LecturerDTO&gt;, List&lt;LecturerVO&gt;&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LecturerVO&gt; <span class="title">apply</span><span class="params">(StdListResponse&lt;LecturerDTO&gt; listRes)</span> <span class="keyword">throws</span> Exception </span>&#123;]</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">final</span> List&lt;LecturerVO&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">if</span> (!listRes.isSuccess()) <span class="keyword">return</span> result;</span><br><span class="line">          <span class="keyword">final</span> StdArrayData&lt;LecturerDTO&gt; data = listRes.getData();</span><br><span class="line">          <span class="keyword">if</span> (data == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">          <span class="keyword">final</span> List&lt;LecturerDTO&gt; array = data.getArray();</span><br><span class="line">          <span class="keyword">if</span> (array == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">          <span class="keyword">for</span> (LecturerDTO dto : array) &#123;</span><br><span class="line">              <span class="keyword">if</span> (dto == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// transform方法实现了“网络传输数据”转化为“UI展示数据”的过程</span></span><br><span class="line">              result.add(dto.transform());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">         &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="keyword">return</span> Collections.&lt;LecturerVO&gt;emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">  .as(AutoDispose.autoDisposable(AndroidLifecycleScopeProvider.from(<span class="keyword">this</span>)))</span><br><span class="line">  .subscribe(<span class="keyword">new</span> ObserverAdapter&lt;StdResponse&lt;User&gt;&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;LecturerVO&gt; lecturers)</span></span>&#123;</span><br><span class="line">          <span class="comment">// 直接接收到用于UI展示的数据</span></span><br><span class="line">  <span class="comment">// do sth.</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>Retrofit+Coroutines</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">  <span class="keyword">val</span> lecturerList: MutableList&lt;LecturerVO&gt; = </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">        CourseApi.getLecturerListKt(courseId)</span><br><span class="line">  ?.body().<span class="keyword">data</span>?.array</span><br><span class="line">  <span class="comment">// transform方法实现了“网络传输数据”转化为“UI展示数据”的过程</span></span><br><span class="line">  ?.map&#123; it.transform() &#125; <span class="comment">// 运用高阶函数`map`进行DTO-&gt;VO的转化</span></span><br><span class="line">  ?:<span class="keyword">return</span> emptyList()</span><br><span class="line">      &#125;<span class="keyword">catch</span>(e: Exception)&#123;</span><br><span class="line">        emptyList()</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// 直接接收到用于UI展示的数据</span></span><br><span class="line">  <span class="comment">// do sth.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3 并行执行两个网络请求</li></ul><p>拉去课程的<strong>课时列表</strong>并展示; 拉去<strong>课程的详情</strong>并展示</p><p><code>Retrofit+RxJava</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 根据课程ID,获取课程课时目录</span></span><br><span class="line">Observable&lt;List&lt;CourseCataLog&gt;&gt; catalogObs = CourseApi.getCataLog(courseId);</span><br><span class="line"><span class="comment">// 2 根据课程ID,获取课程详情</span></span><br><span class="line">Observable&lt;CourseProfile&gt; profileObs = CourseApi.getProfile(courseId);</span><br><span class="line"><span class="comment">// 3 将二者返回的数据聚合成课程实体</span></span><br><span class="line">Observable&lt;Course&gt; merge = Observable.merge(</span><br><span class="line">        catalogObs.flatMap(<span class="keyword">new</span> Function&lt;List&lt;CourseCataLog&gt;, ObservableSource&lt;Course&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;Course&gt; <span class="title">apply</span><span class="params">(List&lt;CourseCataLog&gt; courseCataLogs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.just(<span class="keyword">new</span> Course(courseCataLogs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        profileObs.flatMap(<span class="keyword">new</span> Function&lt;CourseProfile, ObservableSource&lt;Course&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;Course&gt; <span class="title">apply</span><span class="params">(CourseProfile courseProfile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.just(<span class="keyword">new</span> Course(courseProfile));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 4 执行合并后的Obseravle</span></span><br><span class="line">merge.subscribeOn(Schedulers.io())</span><br><span class="line">  .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">  .as(AutoDispose.autoDisposable(AndroidLifecycleScopeProvider.from(<span class="keyword">this</span>)))</span><br><span class="line">  .subscribe(<span class="keyword">new</span> ObserverAdapter&lt;Course&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 5.1 更新profile部分UI</span></span><br><span class="line">      <span class="keyword">final</span> CourseProfile profile = course.getProfile();</span><br><span class="line">      <span class="keyword">if</span>(profile != <span class="keyword">null</span>)&#123; updateProfileUI(profile); &#125;</span><br><span class="line">      <span class="comment">// 5.2 更新catalog部分UI</span></span><br><span class="line">      <span class="keyword">final</span> List&lt;CourseCatalog&gt; catalogs = course.getCatalogs();</span><br><span class="line">      <span class="keyword">if</span>(catalogs != <span class="keyword">null</span>)&#123; updateCatalogUI(catalogs); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>Retrofit+Coroutines</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">  <span class="comment">// 1 根据课程ID,获取课程课时目录</span></span><br><span class="line">  <span class="keyword">val</span> catalogDeferred = async &#123; CourseApi.getCataLogKt(courseId) &#125;</span><br><span class="line">  <span class="comment">// 2 根据课程ID,获取课程详情</span></span><br><span class="line">  <span class="keyword">val</span> profileDeferred = async &#123; CourseApi.getProfileKt(courseId) &#125;</span><br><span class="line">  <span class="comment">// 3.1 更新profile部分UI</span></span><br><span class="line">updateProfileUI(profileDeferred.await()?:<span class="keyword">return</span><span class="symbol">@launch</span>);</span><br><span class="line">  <span class="comment">// 3.2 更新catalog部分UI</span></span><br><span class="line">  updateCatalogUI(profileDeferred.await()?:<span class="keyword">return</span><span class="symbol">@launch</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说Kotlin语法的简洁性, 相同的逻辑代码, 使用Kotlin Coroutines减少了一半以上的代码量。而且协程的异步代码的同步写法可读性高, 逻辑也更为清晰，实乃提供工作效率的利器！</p><h3 id="3-软技能提升·主人翁意识"><a href="#3-软技能提升·主人翁意识" class="headerlink" title="3 软技能提升·主人翁意识"></a>3 软技能提升·<strong>主人翁意识</strong></h3><p>​        工作不是完成日常需求就行，应该更多地考虑工程的稳定性，不同职能之间的协作效率的提升，如何优化开发/测试流程等等。比如，前文提到的<code>Genos</code>系列开发调试工具的设计，不仅方便了我们开发人员定位问题，同时极大地方便了测试人员的测试工作。再比如，需求评审会和设计评审会的功能是否有大量重复的部分，是否可以合二为一，减少重复无意义的会议，给前端/客户端开发人员留更多的时间进行开发？还有，应当自发整理项目工程文档，为工作内容留下记录，哪怕有任何紧急情况不在岗位上，也可以很好的做好交接。</p><p>​        这些都是完成日常工作之余，值得思考的问题。提升主人翁意识，提高工作的效率，创造舒适的工作体验。</p><h3 id="4-其他杂事"><a href="#4-其他杂事" class="headerlink" title="4 其他杂事"></a>4 其他杂事</h3><p>前文挑了几个值得展开讨论的要点进行了分析，除此之外2019年我还做了些什么事呢？</p><h4 id="①-个人github"><a href="#①-个人github" class="headerlink" title="① 个人github"></a>① 个人github</h4><p>这一年疏于Github的经营, commit记录也是零散惨淡。惭愧惭愧。<br><img src="/posts/62750/github_commits.png" alt></p><h4 id="②-聚慧编程-在线评测系统"><a href="#②-聚慧编程-在线评测系统" class="headerlink" title="② 聚慧编程(在线评测系统)"></a>② 聚慧编程(在线评测系统)</h4><p><img src="/posts/62750/juhui_logo.png" alt></p><p>我在2018年搭建的<em>新城中学OJ系统</em>现已更名为<a href="http://oj.relish.wang" target="_blank" rel="noopener"><strong>聚慧编程</strong></a>。目前已有369名用户在此学习和训练编程语言。不过都是俊杰在打理，我就出个服务器的钱。</p><h4 id="③-个人博客"><a href="#③-个人博客" class="headerlink" title="③ 个人博客"></a>③ 个人博客</h4><p>个人域名的博客实在没啥人气。反倒是我的CSDN博客稍稍有些气色。访问量破20w了，积分榜总排名26648。留个记录吧。交给2020年的我来赶超吧。</p><p><img src="/posts/62750/my_csdn_data.png" alt></p><p>​        小婷婷提醒我说:”你去年就18w访问量了, 今年才20w。你这访问量明明就是靠前几年的文章涨的，你就是吃老本。” 对对对，我是吃老本，罪过罪过。明年加油！</p><h2 id="二、生活与情感"><a href="#二、生活与情感" class="headerlink" title="二、生活与情感"></a>二、生活与情感</h2><h3 id="1-新住所与小惬意"><a href="#1-新住所与小惬意" class="headerlink" title="1 新住所与小惬意"></a>1 新住所与小惬意</h3><p>​        换次工作搬次家，相当折腾。这次兜兜转转搬到了我实习之初住的地方的——隔壁小区。因为我2年多前租的房子拆迁了(目瞪狗呆)，小道消息据说每户平均获赔千万级别(再次目瞪狗呆)。</p><p>​        <img src="/posts/62750/old_settlement.png" alt></p><p>​        这次虽然搬的还是单间，而且没有独卫，还是一楼，但好在房间大啊，除了房间原来就有的2.2m的大床和又大又长的靠墙衣柜(目测0.8m*2.2m*2.5m)外，还可以放下两张书桌, 一张化妆台, 一个约门高的小书架, 还有个小阳台晾衣服，剩下的面积还可以打个地铺。(咦？我为什么要打地铺？) 虽然是一楼其实并不潮湿, 因为它朝南呀。血——赚——(模仿敬汉卿说话)</p><p>​        房东叔叔和房东阿姨人很好，还经常做菜给我们吃, 还教我们做菜。</p><p>​        小区里有个室外游泳池，仅在暑假开放两个月。￥20/人不计时。虽然池子小，但强在离家近。</p><p>​        把轮滑鞋带来了, 不过好像没玩几次, 就在钱塘江边滑了几次。后来买了肥宅快乐环, 也就不再出去滑了。</p><h3 id="2-人际关系与变化"><a href="#2-人际关系与变化" class="headerlink" title="2 人际关系与变化"></a>2 人际关系与变化</h3><p>​        原来在大搜车的不少老朋友们都四散到了各地，阿呆薪资double, 还在北京; 家🍐涨薪60%, 突破20k大关; 耗子也double了，去了蚂蚁金服。大家都有美好的前程。</p><p>​        我也结识了一群新朋友。经常和小剑剑一起搓炉石，周五还搭他的车回家，是个聊天爱发黄图的帅小伙; 和沉默的阿岩一起来到这个新环境，临走时还没好好打招呼; 看着洋洋身上的拼劲，像看到当年的自己，小小的眼睛装着大大的疑惑。哈哈哈哈。</p><h3 id="3-牙牙牙牙"><a href="#3-牙牙牙牙" class="headerlink" title="3 牙牙牙牙"></a>3 牙牙牙牙</h3><p>​        单独抽一节说说这个牙的事。你看这个牙，它又丑又歪<del>skr</del></p><p><img src="/posts/62750/teeth.png" alt></p><p>​        牙疼不是病, 疼起来真要命。这四颗牙，没一颗好牙。尤其下面那两颗，害的我下排牙都对不齐上排的牙了。每颗牙的拔牙费用2134依次递增, 越歪的越贵，掏空了我医保的历年余额。总共大概花了￥4000+把。血——亏——。拔完牙的一周里, 只能喝粥度日, 了无生趣。以后有了孩子一定好好带他/她保护牙齿，定期检查牙齿，免得受这份罪。</p><h3 id="4-新型冠状病毒"><a href="#4-新型冠状病毒" class="headerlink" title="4  新型冠状病毒"></a>4  新型冠状病毒</h3><blockquote><p>2019新型冠状病毒，即“2019-nCoV”，  因<a href="https://baike.baidu.com/item/2019年武汉病毒性肺炎病例/24236082" target="_blank" rel="noopener">2019年武汉病毒性肺炎病例</a>而被发现，2020年1月12日被<a href="https://baike.baidu.com/item/世界卫生组织/483426" target="_blank" rel="noopener">世界卫生组织</a>命名。冠状病毒是一个大型病毒家族，已知可引起感冒以及中东呼吸综合征<em>（MERS）</em>和严重急性呼吸综合征<em>（SARS）</em>等较严重疾病。新型冠状病毒是以前从未在人体中发现的冠状病毒新毒株。</p></blockquote><p>出门要戴口罩了,  符合标准的口罩还买不到。回武汉的小伙伴很慌,  回家路过武汉的小伙伴也慌。听说武汉的小伙伴出门是这样的:</p><p><img src="/posts/62750/ncov.png" alt></p><h2 id="三、娱乐与消遣"><a href="#三、娱乐与消遣" class="headerlink" title="三、娱乐与消遣"></a>三、娱乐与消遣</h2><h3 id="1-动漫"><a href="#1-动漫" class="headerlink" title="1 动漫"></a>1 动漫</h3><h4 id="①-JoJo的奇幻冒险"><a href="#①-JoJo的奇幻冒险" class="headerlink" title="① JoJo的奇幻冒险"></a>① JoJo的奇幻冒险</h4><p>在景1的鼓动下, 开始从第一季看《JOJO》。差点被画风劝退, 而后一发不可收拾。就连小婷婷看了之后也开始“木大木大”“平角裤平角裤”了。一口气看完了五季。坐等2020年的第六季——《石之海》。</p><h4 id="②-我的英雄学院"><a href="#②-我的英雄学院" class="headerlink" title="② 我的英雄学院"></a>② 我的英雄学院</h4><p>要是<em>通行百万</em>当主角就好了，他那么努力还是拼不过主角光环的<em>绿谷</em>。</p><h4 id="③-海贼王"><a href="#③-海贼王" class="headerlink" title="③ 海贼王"></a>③ 海贼王</h4><p>听网友说，春节估计看不到<em>路飞</em>打<em>凯多</em>, 估计要到清明节。顺便一提《狂热行动》还不错。</p><h4 id="④-齐木楠雄的灾难·始动篇"><a href="#④-齐木楠雄的灾难·始动篇" class="headerlink" title="④ 齐木楠雄的灾难·始动篇"></a>④ 齐木楠雄的灾难·始动篇</h4><p>一口气看完了6集<del>爽</del>漫画早就完结了居然还能出动漫！听说是网飞给的钱太多了…资本的力量真牛逼…</p><h3 id="2-游戏"><a href="#2-游戏" class="headerlink" title="2 游戏"></a>2 游戏</h3><p><strong>Nintendo Switch</strong></p><p><img src="/posts/62750/games.png" alt></p><blockquote><p>我曾拥有你，想到就心酸。</p></blockquote><p>上图大部分游戏都卖了回血了。只剩下《塞尔达传说·旷野之息》和《超级马里奥·奥德赛》。</p><ul><li>舞力全开2018 ￥130</li><li>喷射战士2 ￥240</li><li>星之卡比 ￥254</li><li>出发吧皮卡丘 ￥190</li><li>马里奥赛车8 ￥284</li><li>织梦岛 ￥250</li></ul><p>回血的钱又入手了《健身环大冒险》。</p><p>稍微评价一下2019年玩的几个游戏：</p><h4 id="①-《塞尔达传说·旷野之息》"><a href="#①-《塞尔达传说·旷野之息》" class="headerlink" title="① 《塞尔达传说·旷野之息》"></a>① 《塞尔达传说·旷野之息》</h4><p>​        虽然是2018年年初就买了的游戏, 但我一直没玩。很奇怪，大家越是吹的厉害，我越是不想玩。后来慢慢玩下去，沉浸在海拉鲁大陆里之后，我只想说:”真香！”。旷野之息里有很多细节真的做的很棒，不注意的话不会发现。比如，<strong>快要下雨了蜻蜓会飞得很低</strong>。</p><p>​        前期一直是那种见了怪就跑, 不敢干架，到处乱跑，错过很多好装备。后来入了DLC，开始肝<strong>剑之试炼</strong>。对于我这种手残党来说，<strong>剑之试炼</strong>真是太难了，被关卡虐得自闭。好几次去网上找<strong>盾跳穿墙</strong>的教程。练了好几次，明明储存了扭曲就是穿不了墙，我也是服了。最后老老实实地干架。肝了几周总算成功开光三次。<strong>剑之试炼</strong>出来之后，干架都有了自信。直接去了<strong>岛之试炼</strong>，那叫一个爽。</p><p>​        再后来神兽任务都做完了，就差救公主了。但我还是喜欢在这片美丽的大陆上旅旅游，采采蘑菇，放放火，炸炸鱼。</p><p><img src="/posts/62750/zelda.png" alt></p><p>​        在2019年6月11日的任天堂E3展上, 放出重磅消息——《塞尔达传说·旷野之息》续作正在开发中。后来又有知名游戏主播称2020年就能玩上(不知道是不是有内幕)。这个要放入2020年的规划里(嗯, 确信，没错。认真脸。)。</p><h4 id="②-《塞尔达传说·织梦岛》"><a href="#②-《塞尔达传说·织梦岛》" class="headerlink" title="② 《塞尔达传说·织梦岛》"></a>② 《塞尔达传说·织梦岛》</h4><p>​        说实话, 织梦岛这游戏真的配不上它的售价。剧情主线太短了，而且总是在固定的路线上走来走去，没多久就没新鲜感了(可能我被旷野之息的开放世界惯坏了吧)。通关后我就卖给Mawh了，听说后来他也没怎么玩就又卖了。哈哈哈哈。果然大家对烂作的认知都是统一的。</p><h4 id="③-《煮糊了2》"><a href="#③-《煮糊了2》" class="headerlink" title="③ 《煮糊了2》"></a>③ 《煮糊了2》</h4><p>​        买的电子版, 去年跟景1玩过一点点。今年跟小剑剑、景1又分别玩了一次，打到第二章了。说实话这游戏太考验配合了，一不小心就做错了，真是游戏如其名<strong>分手厨房</strong>。</p><h4 id="④-《喷射战士2》"><a href="#④-《喷射战士2》" class="headerlink" title="④ 《喷射战士2》"></a>④ 《喷射战士2》</h4><p>​        不是喜欢的类型，已出。</p><h4 id="⑤-《人类一败涂地》"><a href="#⑤-《人类一败涂地》" class="headerlink" title="⑤ 《人类一败涂地》"></a>⑤ 《人类一败涂地》</h4><p>​        本来以为只有跟同样买了《人类一败涂地》的Switch玩家才能一起联机玩。后来才发现可以本机两个手柄就可以双人进行游戏了。跟景1玩了一晚上，相当欢乐。</p><h4 id="⑥-《出发吧-皮卡丘》"><a href="#⑥-《出发吧-皮卡丘》" class="headerlink" title="⑥ 《出发吧!皮卡丘》"></a>⑥ 《出发吧!皮卡丘》</h4><p>​        其实是去年(2018)年底买的，感觉一般。只能抓野怪，都不能与野怪对战，没有灵魂。打完四大天王，还没抓超梦就卖了。还在超梦的洞窟里捡了好几个大师球。</p><h4 id="⑦-《宝可梦·剑》"><a href="#⑦-《宝可梦·剑》" class="headerlink" title="⑦ 《宝可梦·剑》"></a>⑦ 《宝可梦·剑》</h4><p>​        比《出发吧!皮卡丘》好多了。极巨化还是挺有意思的。近期抓了只百变怪，沉迷配种中。期待春节回家和小伙伴交换宝可梦。</p><h4 id="⑧-《健身环大冒险》"><a href="#⑧-《健身环大冒险》" class="headerlink" title="⑧ 《健身环大冒险》"></a>⑧ 《健身环大冒险》</h4><p>​        《健身环大冒险》是任天堂自主研发的，不是外面的野鸡游戏工作室做的小垃圾可以比的。网上又不少专业的健身教练评测，都是正面的评价，也就是说健身环大冒险真的可以健身。而且效果还不错，还会为你纠正姿势。</p><p><strong>炉石传说</strong></p><p>​        什么<strong>炉石传说</strong>？是那个<strong>酒馆战旗</strong>的启动器吗？</p><p><img src="/posts/62750/heartstone_chess.png" alt></p><p>​        酒馆战旗的火爆程度都快盖过<strong>巨龙降临</strong>新版本了。反正我是记不得巨龙降临有哪些强势构筑了。每次上线，好友们都在下棋。下棋最大的乐趣就是双排。互通情报，互相py。比如，第一回合遇到小伙伴就商量好都不下怪；中后期遇到小伙伴了，开黑双方有一边鱼人快成形了但血量堪忧了，就让小伙伴站位py一下, 放点水，被小入一点点。一个吃鸡另一人还能恰烂分, 岂不美哉。但也有错误估计小伙伴的实力，饶的太多，导致提前速8的情况…这就是另一个故事了。</p><p>​        战旗初始积分4000分。我目前战旗天梯分数<strong>6494</strong>，留个记录。来年再战。</p><h3 id="3-电子设备"><a href="#3-电子设备" class="headerlink" title="3 电子设备"></a>3 电子设备</h3><h4 id="①-Magic-Keyboard"><a href="#①-Magic-Keyboard" class="headerlink" title="① Magic Keyboard"></a>① Magic Keyboard</h4><p>​        嫌之前的<code>Cherry</code>入门款键盘太占桌面面积了, 就入了一块Magic Keyboard。</p><h4 id="②-Apple-Watch-S5"><a href="#②-Apple-Watch-S5" class="headerlink" title="② Apple Watch S5"></a>② Apple Watch S5</h4><p>​        本来想给小婷婷当做生日礼物的，可惜她的手机版本太低，连接不了Apple Watch S5。只好去老赵那淘了一台<strong>iPhone 5SE</strong>(这个就不单独记录了), 手表就给我自己用了。后来去Apple 西湖修电脑屏幕(有点花屏)又顺便买了一块蓝色布表带。说实话还是硅胶舒服, 而且耐脏; 布表带比较轻，但是待在手腕上不安分，滑来滑去的，系的紧了又勒手。没几天又换回硅胶表带了。</p><h2 id="四、总结与规划"><a href="#四、总结与规划" class="headerlink" title="四、总结与规划"></a>四、总结与规划</h2><h3 id="2019就此告别"><a href="#2019就此告别" class="headerlink" title="2019就此告别"></a>2019就此告别</h3><p>Bye~</p><h3 id="2020新的征程"><a href="#2020新的征程" class="headerlink" title="2020新的征程"></a>2020新的征程</h3><p>​    制定几个目标吧。目标不比总结，有明确方向和内容就行，不需要长篇大论。</p><h4 id="①-学习目标"><a href="#①-学习目标" class="headerlink" title="① 学习目标"></a>① 学习目标</h4><p>​        计划<strong>为github上的<code>kotlin</code>项目提交代码</strong>。</p><h4 id="②-开支目标"><a href="#②-开支目标" class="headerlink" title="② 开支目标"></a>② 开支目标</h4><p>​        今年的支付宝年账单有够扯的，我花的居然比我挣得还多。还好我记了账不然就被它骗了。2020年计划<strong>继续保持今年的开支水平</strong>吧。毕竟2020年有更多需要花钱的地方。加油吧！</p><h4 id="③-游戏目标"><a href="#③-游戏目标" class="headerlink" title="③ 游戏目标"></a>③ 游戏目标</h4><p>​        少买点游戏吧，要买也买实体版，回头转卖还能回血。之前一时脑热买了好几个电子版游戏，结果不是自己喜欢的类型…目标明确一下，除了<strong>《塞尔达传说·旷野之息》续作</strong>，其他游戏都不买了。要是续作跳票了，那也<strong>只能买一部游戏</strong>。</p><p>这次话太多了, 不符合我的风格，我还是喜欢<em>张牧之</em>的发言: </p><blockquote><p>“咳咳, 出发!”</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.kotlincn.net/" target="_blank" rel="noopener">Kotlin中文站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2019就此告别2020新的征程&quot;&gt;&lt;a href=&quot;#2019就此告别2020新的征程&quot; class=&quot;headerlink&quot; title=&quot;2019就此告别2020新的征程&quot;&gt;&lt;/a&gt;2019就此告别2020新的征程&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、学习与工作&quot;&gt;&lt;a href=&quot;#一、学习与工作&quot; class=&quot;headerlink&quot; title=&quot;一、学习与工作&quot;&gt;&lt;/a&gt;一、学习与工作&lt;/h2&gt;&lt;p&gt;2019年年初阔别了工作两年的&lt;a href=&quot;https://www.dasouche.com/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;大搜车&lt;/em&gt;&lt;/a&gt;，满怀新鲜感来到了&lt;a href=&quot;https://ececloud.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;学智云&lt;/em&gt;&lt;/a&gt;。至此开启了我的梦幻2019年。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="https://relish.wang/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://relish.wang/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>如何上传Android构件(aar)到sonatype远程maven仓库</title>
    <link href="https://relish.wang/posts/3877/"/>
    <id>https://relish.wang/posts/3877/</id>
    <published>2019-06-16T02:45:41.000Z</published>
    <updated>2020-01-19T01:50:46.575Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="注册Sonatype账号"><a href="#注册Sonatype账号" class="headerlink" title="注册Sonatype账号"></a>注册Sonatype账号</h2><p>根据<a href="https://blog.csdn.net/jinjinnsfz1991/article/details/80688775" target="_blank" rel="noopener">《Sonatype Nexus在Maven Central Repository开户实践笔记》</a>所述步骤，会走到”验证域名归属”这一步。最快的方式就是添加为自己的域名添加TXT记录。</p><h2 id="添加TXT记录"><a href="#添加TXT记录" class="headerlink" title="添加TXT记录"></a>添加TXT记录</h2><p>以阿里云(万网)为例(relish.wang是笔者的域名)</p><p>1 打开阿里云控制台首页<a href="https://homenew.console.aliyun.com/" target="_blank" rel="noopener">https://homenew.console.aliyun.com/</a></p><a id="more"></a><p>2 选择域名</p><p><img src="/posts/3877/choose_domain.png" alt></p><p>3 选择对应域名点击【解析】</p><p><img src="/posts/3877/click_analyze.png" alt="image-20190616152609464"></p><p>4 添加TXT记录</p><p><img src="/posts/3877/add_txt_record.png" alt></p><p>5 验证TXT记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -q=TXT yourdomain.com</span><br></pre></td></tr></table></figure><p><img src="/posts/3877/nslookup.png" alt></p><p>6 验证成功后在工单上回复管理员(在管理员确认过了之后，你也可以删除那条TXT记录)</p><p>7 这时你就可以上传你自己的Android构建包了。第一次上传成功后，需再次在原来的工单上回复管理员，告知他你已经上传成功了。</p><p>##</p><blockquote><p>hkp://pool.sks-keyservers.net</p></blockquote><p>改为</p><blockquote><p>hkp://ipv4.pool.sks-keyservers.net</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver hkp://ipv4.pool.sks-keyservers.net --send-keys XXXXXXXX</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/u012291393/article/details/78768547" target="_blank" rel="noopener">《Letsencrypt通过DNS TXT记录来验证域名有效性》</a></p><p><a href="https://blog.csdn.net/jinjinnsfz1991/article/details/80688775" target="_blank" rel="noopener">《Sonatype Nexus在Maven Central Repository开户实践笔记》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注册Sonatype账号&quot;&gt;&lt;a href=&quot;#注册Sonatype账号&quot; class=&quot;headerlink&quot; title=&quot;注册Sonatype账号&quot;&gt;&lt;/a&gt;注册Sonatype账号&lt;/h2&gt;&lt;p&gt;根据&lt;a href=&quot;https://blog.csdn.net/jinjinnsfz1991/article/details/80688775&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Sonatype Nexus在Maven Central Repository开户实践笔记》&lt;/a&gt;所述步骤，会走到”验证域名归属”这一步。最快的方式就是添加为自己的域名添加TXT记录。&lt;/p&gt;
&lt;h2 id=&quot;添加TXT记录&quot;&gt;&lt;a href=&quot;#添加TXT记录&quot; class=&quot;headerlink&quot; title=&quot;添加TXT记录&quot;&gt;&lt;/a&gt;添加TXT记录&lt;/h2&gt;&lt;p&gt;以阿里云(万网)为例(relish.wang是笔者的域名)&lt;/p&gt;
&lt;p&gt;1 打开阿里云控制台首页&lt;a href=&quot;https://homenew.console.aliyun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://homenew.console.aliyun.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://relish.wang/categories/Android/"/>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="构建" scheme="https://relish.wang/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="aar" scheme="https://relish.wang/tags/aar/"/>
    
      <category term="maven" scheme="https://relish.wang/tags/maven/"/>
    
      <category term="上传" scheme="https://relish.wang/tags/%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="脚本" scheme="https://relish.wang/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>博客整容记</title>
    <link href="https://relish.wang/posts/41110/"/>
    <id>https://relish.wang/posts/41110/</id>
    <published>2019-05-20T03:57:29.000Z</published>
    <updated>2019-06-15T18:43:37.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/posts/41110/cover.png" alt="封面"></p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>自从博客搭建(2017.8)至今，一直用着hexo的next主题，也从未想过做任何美化的工作。某次在搜索资料时，看到某位网友的个人博客，一时间惊为天人。卧槽，这也太好看了吧！我的博客简直就是个草窝啊我去。随后我就开始了我的博客美化工作。</p><a id="more"></a><h2 id="前后对比"><a href="#前后对比" class="headerlink" title="前后对比"></a>前后对比</h2><p>国际惯例先上图:</p><p><img src="/posts/41110/compare.png" alt="前后对比图"></p><p>*<em>博客美化前: *</em><a href="before.gif">查看动图</a></p><p>*<em>博客美化后: *</em><a href="after.gif">查看动图</a></p><ul><li>1 <strong>github</strong>跳转徽标</li><li>2 <strong>主题色</strong>由黑色变成蓝色(#49b1f5)</li><li>3 设置自己喜欢的<strong>背景图片</strong>,并设置透明背景</li><li>4 可以与鼠标互动的<strong>萌萌哒的妹子</strong>(live2d)</li><li>5 鼠标点击空白区域出现<strong>爱心</strong>(向上飘然后隐退)</li><li>6 修改<strong>文章列表分割线</strong>(丑丑的横线-&gt;透明间距)， 也修改了<strong>文章的宽度</strong>(原先的空白区域太多，不美观)</li><li>7 使用<strong>圆形头像(</strong>鼠标放上去还有旋转动画哟)</li><li>8 文章<strong>阅读次数</strong>改为<strong>热度</strong>，添加<strong>字数统计</strong>，<strong>阅读时长</strong></li></ul><h3 id="教程时间"><a href="#教程时间" class="headerlink" title="教程时间"></a>教程时间</h3><h3 id="1-设置github跳转徽标"><a href="#1-设置github跳转徽标" class="headerlink" title="1 设置github跳转徽标"></a>1 设置github跳转徽标</h3><p>修改文件位置:<code>/themes/next/layout/_layout.swig</code></p><p>在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>下方添加如下代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 记得改成你的github地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/relish-wang"</span>&gt;</span> </span><br><span class="line"> <span class="comment">&lt;!-- 这里我的博客的主题色是#49b1f5, 你可以根据自己喜好设置颜色 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"80"</span> <span class="attr">height</span>=<span class="string">"80"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 250 250"</span> <span class="attr">style</span>=<span class="string">"fill: #49b1f5; color: #fff; position: absolute; top: 0; border: 0; right: 0"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">style</span>=<span class="string">"transform-origin: 130px 106px"</span> <span class="attr">class</span>=<span class="string">"octo-arm"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">class</span>=<span class="string">"octo-body"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">style</span>=<span class="string">"transform-origin: 130px 106px"</span> <span class="attr">class</span>=<span class="string">"octo-arm"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">class</span>=<span class="string">"octo-body"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/41110/1github.png" alt="github徽标"></p><h3 id="2-主题色由黑色变成蓝色"><a href="#2-主题色由黑色变成蓝色" class="headerlink" title="2 主题色由黑色变成蓝色"></a>2 主题色由黑色变成蓝色</h3><p>修改主题色需要修改有多处地方</p><ul><li><p>1 github徽标颜色，见前文</p></li><li><p>2 修改网站头部颜色</p><p>在文件<code>themes/next/source/css/_custom/custom.styl</code>中添加:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 修改网站头部颜色</span><br><span class="line"><span class="selector-class">.headband</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">3px</span>;</span><br><span class="line">    background: #ff0000; // 主题色: 主页最上面的加载条颜色</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-meta</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    background: #00ff00; // 主题色: 主页title/subtitle上面的背景色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3 如果你还想把按钮的hover颜色的也改成主题色的话:</p><p>在<code>/themes/next/source/css/_variables/custom.styl</code>添加:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$btn-default-hover-bg = #49b1f5 // 主题色</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-设置自己喜欢的背景图片-并设置半透明背景"><a href="#3-设置自己喜欢的背景图片-并设置半透明背景" class="headerlink" title="3 设置自己喜欢的背景图片,并设置半透明背景"></a>3 设置自己喜欢的<strong>背景图片</strong>,并设置半透明背景</h3><p><strong>1 设置背景图片</strong></p><p> 在<code>/themes/next/source/css/_custom/custom.styl</code>中添加:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    // 网站背景图</span><br><span class="line">    background-image:url(../images/background.jpg);</span><br><span class="line">    <span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</span><br><span class="line">    <span class="selector-tag">background-attachment</span><span class="selector-pseudo">:fixed</span>;</span><br><span class="line">    <span class="selector-tag">background-position</span><span class="selector-pseudo">:50</span>% 50%;</span><br><span class="line">    <span class="selector-tag">background-size</span>: <span class="selector-tag">cover</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2 设置透明度</strong></p><p><strong>2.1 修改主页文章列表的背景色</strong></p><p>在<code>themes/next/source/css/_custom/custom.styl</code>中添加:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(202, 203, 203, .5);</span><br><span class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(202, 203, 204, .5);</span><br><span class="line">   background: rgba(255,255,255,0.8); // 主页文章列表-文章item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/41110/sidebar_transparent.png" alt="文章列表透明度"></p><p><strong>2.2 修改侧边栏透明度</strong></p><ul><li>2.2.1修改<code>themes/next/source/css/_schemes/Pisces/_layout.styl</code>的以下节点下的<code>background</code>属性<ul><li><code>.header-inner</code>节点: 由<code>white</code>改为<code>rgba(255,255,255,0.75);</code>(0.75表示透明度。0-全透明;1-不透明)</li><li><code>.content-wrap</code>节点：由<code>white</code>改为<code>rgba(255,255,255,0);</code></li><li><code>.sidebar</code>节点: 由<code>white</code>改为<code>rgba(255,255,255,0);</code></li></ul></li><li>2.2.2 在同一个文件夹下<code>_sidebar.styl</code>的<code>..sidebar-inner</code>节点下的<code>background</code>属性由<code>white;</code>改成<code>rgba(255,255,255,0.75);</code></li></ul><p><img src="/posts/41110/article_transparent.png" alt="侧边栏透明度"></p><p><strong>2.3 修改页面底部页数布局透明度</strong>  <img src="/posts/41110/pagination.png" alt="换页布局"></p><p>  在<code>/themes/next/source/css/_common/components/pagination.styl</code>中修改:</p><p>  <img src="/posts/41110/2bg.png" alt="页面底部页数透明度"></p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pagination</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0px</span> <span class="number">0px</span>; <span class="comment">/* 底部换页布局 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(255,255,255,0.75);</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid $pagination-border;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.4 修改按钮的透明度</strong></p><p>在<code>themes/next/source/css/_common/components/post/post-button.styl</code>中的<code>.post</code>节点的<code>.btn</code>的<code>background</code>属性修改为<code>transparent;</code>(当然如果你觉得白色按钮也挺美观的，也可以不改。)</p><p><img src="/posts/41110/button_transparent.png" alt="按钮透明度"></p><h3 id="4-可以与鼠标互动的萌萌哒的妹子-live2d"><a href="#4-可以与鼠标互动的萌萌哒的妹子-live2d" class="headerlink" title="4 可以与鼠标互动的萌萌哒的妹子(live2d)"></a>4 可以与鼠标互动的<strong>萌萌哒的妹子</strong>(live2d)</h3><p>请参看开源项目<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a></p><p><strong>4.1 在项目根目录下运行</strong></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p><strong>4.2 在根目录的<code>_config.yml</code>中添加以下配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span> <span class="comment"># 老版本需要设置为true，然后在页面中加入&#123;&#123; live2d() &#125;&#125; &lt;- 并不推荐</span></span><br><span class="line"><span class="attr">  log:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-shizuku</span> <span class="comment"># 设置添加的模型</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">right</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">150</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">true</span> <span class="comment"># 是否在移动端页面上展示</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacity:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure><p><strong>4.3 安装你选择的模型的package</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure><p><strong>4.4 跑起来你就能看到了</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p><img src="/posts/41110/live2d_and_heart.gif" alt="live2d"></p><h3 id="5-鼠标点击空白区域出现爱心-向上飘然后隐退"><a href="#5-鼠标点击空白区域出现爱心-向上飘然后隐退" class="headerlink" title="5 鼠标点击空白区域出现爱心(向上飘然后隐退)"></a>5 鼠标点击空白区域出现爱心(向上飘然后隐退)</h3><p><strong>5.1 保存<code>love.js</code>文件</strong></p><p>将<a href="https://raw.githubusercontent.com/relish-wang/relish-wang.github.io/master/js/src/love.js" target="_blank" rel="noopener">love.js</a>文件保存到<code>/themes/next/source/js/src/</code>目录下, 文件名就取为<code>love.js</code></p><p><strong>5.2 引用<code>love.js</code>文件</strong></p><p>在<code>/themes/next/layout\_layout.swig</code>文件末尾添加js文件引用:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/posts/41110/heart.png" alt="小红心"></p><h3 id="6-修改文章列表分割线"><a href="#6-修改文章列表分割线" class="headerlink" title="6 修改文章列表分割线"></a>6 修改文章列表分割线</h3><p>在<code>themes/next/source/css/_custom/custom.styl</code>中添加以下代码:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"><span class="selector-class">.posts-expand</span> &#123;</span><br><span class="line">    .post &#123;</span><br><span class="line">        margin-top: 0px; // 首页文章item的顶部margin</span><br><span class="line">        margin-bottom: 20px; // 首页文章item的底部margin</span><br><span class="line">        padding: 25px; // 文章内容距离边框的边距</span><br><span class="line">        <span class="selector-tag">-webkit-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 203, <span class="selector-class">.5</span>);</span><br><span class="line">        <span class="selector-tag">-moz-box-shadow</span>: 0 0 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(202, 203, 204, <span class="selector-class">.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-使用圆形头像-旋转动画"><a href="#7-使用圆形头像-旋转动画" class="headerlink" title="7 使用圆形头像+旋转动画"></a>7 使用圆形头像+旋转动画</h3><p>在<code>themes/next/source/css/_common/components/sidebar/sidebar-author.styl</code>末尾添加:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 头像圆形 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="number">#333</span>sf;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </span></span><br><span class="line"><span class="comment">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: -webkit-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: -moz-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 鼠标经过停止头像旋转 </span></span><br><span class="line"><span class="comment">  -webkit-animation-play-state:paused;</span></span><br><span class="line"><span class="comment">  animation-play-state:paused;*/</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Z 轴旋转动画 */</span></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/41110/avatar_rotate.gif" alt="圆形头像旋转"></p><h3 id="8-文章阅读次数改为热度，添加字数统计，阅读时长"><a href="#8-文章阅读次数改为热度，添加字数统计，阅读时长" class="headerlink" title="8 文章阅读次数改为热度，添加字数统计，阅读时长"></a>8 文章<strong>阅读次数</strong>改为<strong>热度</strong>，添加<strong>字数统计</strong>，阅读时长</h3><p>要不是这次想着要给博客整容，我甚至都不知道我早年使用的<strong>不蒜子</strong>早就换了域名了。之前就已经添加了不蒜子计数，我这次只能算修复, 就不赘述添加过程了。</p><p><strong>如何修复:</strong></p><p>将<code>/theme/next/layout/_third-party/analytics/busuanzi-counter.swig</code>中不蒜子的域名<code>dn-lbstatics.qbox.me</code>修改为<code>busuanzi.ibruce.info</code>;</p><h2 id="其他未被我采用的美化方案"><a href="#其他未被我采用的美化方案" class="headerlink" title="其他未被我采用的美化方案"></a>其他未被我采用的美化方案</h2><h3 id="1-动态背景线条"><a href="#1-动态背景线条" class="headerlink" title="1 动态背景线条"></a>1 动态背景线条</h3><p><strong>1 添加功能</strong></p><p>在<code>themes/next/layout/_layout.swig</code>中的<code>&lt;/body&gt;</code>标签前添加以下代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/41110/nest.png" alt="nest"></p><p><strong>2 启用功能</strong></p><p>将<code>/themes/next/_config.yml</code>中的<code>canvas_nest</code>属性改为<code>true</code>（如果之后不想用改成<code>false</code>就行了）:</p><p><img src="/posts/41110/nest_config.png" alt="nest_config"></p><p><strong>3 效果图</strong></p><p><img src="/posts/41110/canvas_nest.gif" alt="效果图"></p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><p>开源项目: <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">EYHN/hexo-helper-live2d</a></p></li><li><p><a href="https://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子官网</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/posts/41110/cover.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;自从博客搭建(2017.8)至今，一直用着hexo的next主题，也从未想过做任何美化的工作。某次在搜索资料时，看到某位网友的个人博客，一时间惊为天人。卧槽，这也太好看了吧！我的博客简直就是个草窝啊我去。随后我就开始了我的博客美化工作。&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="https://relish.wang/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://relish.wang/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://relish.wang/tags/Hexo/"/>
    
      <category term="整容" scheme="https://relish.wang/tags/%E6%95%B4%E5%AE%B9/"/>
    
      <category term="美化" scheme="https://relish.wang/tags/%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯方块Java版</title>
    <link href="https://relish.wang/posts/24453/"/>
    <id>https://relish.wang/posts/24453/</id>
    <published>2019-05-17T06:22:30.000Z</published>
    <updated>2019-06-15T18:43:38.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tetris"><a href="#Tetris" class="headerlink" title="Tetris"></a>Tetris</h1><p>俄罗斯方块Java版本(Cover: 小翼) </p><p>仓库地址: <a href="https://github.com/relish-wang/Tetris" target="_blank" rel="noopener">https://github.com/relish-wang/Tetris</a></p><a id="more"></a><p><strong>关于笔者</strong></p><blockquote><p>景三，程序员，主要从事Android平台基础架构方面的工作，欢迎交流技术方面的问题，可以去我的<a href="https://github.com/relish-wang" target="_blank" rel="noopener">Github</a>提issue或者发邮件至<a href="mailto:relish.wang@gmail.com" target="_blank" rel="noopener">relish.wang@gmail.com</a>与我交流。</p></blockquote><p>@[toc]</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>国际惯例先上图。</p><p><img src="https://raw.githubusercontent.com/relish-wang/Tetris/master/art/default.png" alt="默认皮肤"></p><p><img src="https://raw.githubusercontent.com/relish-wang/Tetris/master/art/skin1.png" alt="皮肤1"><br><img src="https://raw.githubusercontent.com/relish-wang/Tetris/master/art/skin2.png" alt="皮肤2"></p><h2 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h2><h3 id="懒人运行"><a href="#懒人运行" class="headerlink" title="懒人运行"></a>懒人运行</h3><p>先确保你电脑上装了git和java, 然后随便找个合适的文件下运行下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/relish-wang/Tetris.git &amp;&amp; cd Tetris &amp;&amp; java -jar Tetris.jar</span><br></pre></td></tr></table></figure><h3 id="macOS-Linux"><a href="#macOS-Linux" class="headerlink" title="macOS/Linux"></a>macOS/Linux</h3><p>下面方法选其一即可</p><ul><li><p>1 在项目根目录下打开终端执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh start.sh</span><br></pre></td></tr></table></figure></li><li><p>2  在项目根目录下打开终端执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start.sh # 若遇到": permission denied: " 就先执行`chmod +x ./start.sh`</span><br></pre></td></tr></table></figure></li></ul><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>下面方法选其一即可</p><ul><li>1 双击跟目录下<code>start.bat</code>文件</li><li>2 在项目根目录下打开终端执行<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start start.bat</span><br></pre></td></tr></table></figure></li></ul><h2 id="视频下载地址"><a href="#视频下载地址" class="headerlink" title="视频下载地址"></a>视频下载地址</h2><p>《俄罗斯方块》视频教程下载地址(包含图片素材和excel讲解图)</p><p>链接: <a href="https://pan.baidu.com/s/1JOCfsOgEcwq0qvMfK8cqDQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1JOCfsOgEcwq0qvMfK8cqDQ</a><br>提取码: 3u6x </p><h2 id="关于原作"><a href="#关于原作" class="headerlink" title="关于原作"></a>关于原作</h2><p>此版本的《俄罗斯方块》的原作者小翼于2012年12月12日在<a href="http://tieba.baidu.com/f?kw=java&ie=utf-8" target="_blank" rel="noopener">java吧</a>发布此教程。由于教程在当时质量极高，颇受吧友欢迎。但时至今日, 此教程已不再适合作为新手的练手项目。其本人也曾发帖吐槽，不要再学习此教程，也不要因此事过多打扰他。</p><p><img src="https://raw.githubusercontent.com/relish-wang/Tetris/master/art/dont_miss_me.png" alt="别迷恋哥"></p><h3 id="笔者开此仓库原因："><a href="#笔者开此仓库原因：" class="headerlink" title="笔者开此仓库原因："></a>笔者开此仓库原因：</h3><ul><li>1 纪念当年学习java的岁月<br>翻了翻大学时期的移动硬盘。”卧槽, 这是什么？” “咦，厉害厉害!” “牵出来溜溜~”</li><li>2 提供当年的教程和源码<br>帮助小翼拦(劝)截(退)<strong>不懂事的小朋友</strong></li></ul><p><strong>Ps:</strong></p><p>小翼吐槽贴: <a href="http://tieba.baidu.com/p/5102819596?pid=106842140390&cid=#106842140390(http://tieba.baidu.com/p/5102819596?pid=106842140390&cid=#106842140390)" target="_blank" rel="noopener">《【吐槽】不要迷恋哥，J8的破事在J8解决嘛》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tetris&quot;&gt;&lt;a href=&quot;#Tetris&quot; class=&quot;headerlink&quot; title=&quot;Tetris&quot;&gt;&lt;/a&gt;Tetris&lt;/h1&gt;&lt;p&gt;俄罗斯方块Java版本(Cover: 小翼) &lt;/p&gt;
&lt;p&gt;仓库地址: &lt;a href=&quot;https://github.com/relish-wang/Tetris&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/relish-wang/Tetris&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="玩具" scheme="https://relish.wang/categories/%E7%8E%A9%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://relish.wang/tags/Java/"/>
    
      <category term="Tetris" scheme="https://relish.wang/tags/Tetris/"/>
    
      <category term="小翼" scheme="https://relish.wang/tags/%E5%B0%8F%E7%BF%BC/"/>
    
  </entry>
  
  <entry>
    <title>监听Android软键盘弹出与收回事件</title>
    <link href="https://relish.wang/posts/20581/"/>
    <id>https://relish.wang/posts/20581/</id>
    <published>2019-05-07T09:54:09.000Z</published>
    <updated>2019-06-15T18:43:38.232Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>关于作者</strong></p><blockquote><p>景三，程序员，主要从事Android平台基础架构方面的工作，欢迎交流技术方面的问题，可以去我的<a href="https://github.com/relish-wang" target="_blank" rel="noopener">Github</a>提issue或者发邮件至<a href="mailto:relish.wang@gmail.com" target="_blank" rel="noopener">relish.wang@gmail.com</a>与我交流。</p></blockquote><p>@[toc]</p><h2 id="零、项目简介"><a href="#零、项目简介" class="headerlink" title="零、项目简介"></a>零、项目简介</h2><p><a href="https://github.com/relish-wang/KeyboardListener" target="_blank" rel="noopener">KeyboardListener</a>是从<a href="https://github.com/facebook/react-native" target="_blank" rel="noopener">facebook/react-native</a>源码中抽离出来的用于<strong>监听Android软键盘弹出与收回事件</strong>的工具。</p><a id="more"></a><p><strong>扫描二维码下载Demo</strong><br><img src="https://raw.githubusercontent.com/relish-wang/KeyboardListener/master/art/keyboardlistener-demo-qrcode.png" alt="下载Demo的二维码"></p><center><strong>KeyboardListener-Demo.apk</strong></center><h2 id="一、效果演示"><a href="#一、效果演示" class="headerlink" title="一、效果演示"></a>一、效果演示</h2><p><img src="https://raw.githubusercontent.com/relish-wang/KeyboardListener/master/art/with_navigation_bar.gif" alt="显示底部NavigationBar"></p><center><strong>图1 显示底部NavigationBar的情况</strong><br>(注意“屏幕可用高度”的数值)</center><p><img src="https://raw.githubusercontent.com/relish-wang/KeyboardListener/master/art/without_navigation_bar.gif" alt="隐藏底部NavigationBar"></p><center><strong>图2 隐藏底部NavigationBar的情况</strong><br>(注意“屏幕可用高度”的数值)</center><h2 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h2><p>可以直接把<a href="https://github.com/relish-wang/KeyboardListener/tree/master/app/src/main/java/wang/relish/keyboard/util/DisplayMetricsHolder.java" target="_blank" rel="noopener">DisplayMetricsHolder</a>、<a href="https://github.com/relish-wang/KeyboardListener/tree/master/app/src/main/java/wang/relish/keyboard/util/GlobalLayoutListener.java" target="_blank" rel="noopener">GlobalLayoutListener</a>、<a href="(https://github.com/relish-wang/KeyboardListener/tree/master/app/src/main/java/wang/relish/keyboard/util/OnKeyboardChangedListener.java)">OnKeyboardChangedListener</a>三个文件直接拷贝到你的工程里使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rootView.getViewTreeObserver().addOnGlobalLayoutListener(</span><br><span class="line">        <span class="keyword">new</span> GlobalLayoutListener(rootView, <span class="keyword">new</span> OnKeyboardChangedListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 键盘事件</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> isShow         键盘是否展示</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> keyboardHeight 键盘高度(当isShow为false时,keyboardHeight=0)</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> screenWidth    屏幕宽度</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> screenHeight   屏幕可用高度(不包含底部虚拟键盘NavigationBar), 即屏幕高度-键盘高度(keyboardHeight)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> isShow, <span class="keyword">int</span> keyboardHeight, <span class="keyword">int</span> screenWidth, <span class="keyword">int</span> screenHeight)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// do sth.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/relish-wang/KeyboardListener/master/art/desc.png" alt="标注"></p><h2 id="三、更新日志"><a href="#三、更新日志" class="headerlink" title="三、更新日志"></a>三、更新日志</h2><p><a href="https://github.com/relish-wang/KeyboardListener/tree/master/CHANGELOG.md" target="_blank" rel="noopener">CHANGELOG.md</a></p><h2 id="四、致谢"><a href="#四、致谢" class="headerlink" title="四、致谢"></a>四、致谢</h2><p>感谢<a href="https://github.com/facebook/react-native" target="_blank" rel="noopener">facebook/react-native</a>提供代码解决方案。</p><p>本仓库使用的react-native相关代码:</p><ul><li><p><a href="https://github.com/facebook/react-native/blob/135ba492fbd500ec555baadab7ff1db3d537acf3/ReactAndroid/src/main/java/com/facebook/react/ReactRootView.java" target="_blank" rel="noopener">ReactRootView.java</a>里的内部类CustomGlobalLayoutListener</p><p>监听键盘事件的监听器。</p></li><li><p><a href="https://github.com/facebook/react-native/blob/4d95e85f64a496d9b9539b6218d1737997a315da/ReactAndroid/src/main/java/com/facebook/react/uimanager/DisplayMetricsHolder.java" target="_blank" rel="noopener">DisplayMetricsHolder.java</a></p><p>通过反射获取相关尺寸数值。</p></li><li><p><a href="https://github.com/facebook/react-native/blob/4936d284df36071047ce776d9e2486c0371f7b97/ReactAndroid/src/main/java/com/facebook/react/uimanager/PixelUtil.java" target="_blank" rel="noopener">PixelUtil.java</a>(非必要)</p><p>度量单位转换工具。px&lt;-&gt;sp/dp之间的转化。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关于作者&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;景三，程序员，主要从事Android平台基础架构方面的工作，欢迎交流技术方面的问题，可以去我的&lt;a href=&quot;https://github.com/relish-wang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;提issue或者发邮件至&lt;a href=&quot;mailto:relish.wang@gmail.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;relish.wang@gmail.com&lt;/a&gt;与我交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;零、项目简介&quot;&gt;&lt;a href=&quot;#零、项目简介&quot; class=&quot;headerlink&quot; title=&quot;零、项目简介&quot;&gt;&lt;/a&gt;零、项目简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/relish-wang/KeyboardListener&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KeyboardListener&lt;/a&gt;是从&lt;a href=&quot;https://github.com/facebook/react-native&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;facebook/react-native&lt;/a&gt;源码中抽离出来的用于&lt;strong&gt;监听Android软键盘弹出与收回事件&lt;/strong&gt;的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Android常用" scheme="https://relish.wang/categories/Android%E5%B8%B8%E7%94%A8/"/>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="软键盘" scheme="https://relish.wang/tags/%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    
      <category term="键盘弹出" scheme="https://relish.wang/tags/%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA/"/>
    
      <category term="键盘收起" scheme="https://relish.wang/tags/%E9%94%AE%E7%9B%98%E6%94%B6%E8%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>说说2018想想2019</title>
    <link href="https://relish.wang/posts/1828/"/>
    <id>https://relish.wang/posts/1828/</id>
    <published>2019-01-04T06:23:42.000Z</published>
    <updated>2019-06-15T18:43:38.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>1 搭建好了<strong>新城中学OJ系统</strong>(<a href="http://oj.relish.wang/" target="_blank" rel="noopener">http://oj.relish.wang/</a>), 还用上了二级域名，注册人数300+。不仅有学生参与其中，还吸引了当地其他学校的老师前来学习，给俊杰赚足了面子。在此也要感谢zhblue的开源项目hustoj(<a href="https://github.com/zhblue/hustoj" target="_blank" rel="noopener">https://github.com/zhblue/hustoj</a>)。</p><a id="more"></a></li><li><p>2 发表了一篇<strong>博客投稿</strong>了郭霖的微信公众号——<a href="https://mp.weixin.qq.com/s/n-uoO2ygaWWRRWk83MqPxw" target="_blank" rel="noopener">Android Studio项目模板全面解析</a>。</p><p><img src="/posts/1828/tougao.jpg" alt="投稿"></p></li><li><p>3 国庆期间和女票去<strong>南京</strong>好好游玩了一通。拍了很多照片，看了很多地方，吃了很多好吃的。</p><p><img src="/posts/1828/nanjing.jpg" alt="南京之旅"></p></li><li><p>4 进行了一次义无反顾的<strong>杭州-湖州骑行</strong>之旅。骑了6个多小时，可惜最后爆胎了。</p><p><img src="/posts/1828/hu_hang_bike_ride.jpg" alt="杭州-湖州骑行之旅"></p></li><li><p>5 gitlab上拥有比去年更多的<strong>commit</strong>。虽说commit既不能代表代码量也不代表代码质量，但能说明比去年忙。2018年一度加班到身体有些吃不住。</p></li></ul><p><img src="/posts/1828/gitlab.png" alt="gitlab"></p><p><img src="/posts/1828/jiaban.png" alt="加班"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;还有一些烦心事，一一叙述的话就显得杂乱了。搬了一次家，也搬了一次办公地点；购置了Switch，也买了不少游戏，只有奥德赛深得我心，全通关+全收集；收入勉强达到毕业时的期望吧，绝不是高看自己；年终抽到一台天猫精灵，父母甚是喜爱；…</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2018就这么过去了，不能总纠结于过去的烦心事，应当展望未来。我给2019定了8个字的标语，用来警醒自己：</p><p><img src="/posts/1828/slogan.png" alt="口号"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;考虑周全。万事一定要考虑周全，不能想着之后再补。要知道补过的东西，就不再完美了。不是任何尝试都有机会体验第二次的。当你只有一次机会的时候，应当考虑周全，如何把事情做得漂亮，才不至于错过这次机会。也不要在错过之后再抱怨”如果再给我一次机会”。<br>&nbsp; &nbsp; &nbsp; &nbsp;拒绝拖延。2018年我曾给自己定了一套时间表，但最终没能按照计划执行。作息十分不规律。曾经我一度以为千万别把一切都规划了，那将失去无数的可能性。要是所有的事都规划好了，那人生还有什么乐趣。后来我发现我错了，没有规划的人生，只会跟咸鱼一样，毫无方向感，蹦跶了几下也就翻了个身，要知道咸鱼翻身还是咸鱼。所以2019我将制定更多更细致的规划，并克服惰性，将它们执行下去。现在每每想到接下来要做的事情，都充满了期待，瞬间充满了动力。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2019年还有很多值得期待的事。背起行囊，阔步向前。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 搭建好了&lt;strong&gt;新城中学OJ系统&lt;/strong&gt;(&lt;a href=&quot;http://oj.relish.wang/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://oj.relish.wang/&lt;/a&gt;), 还用上了二级域名，注册人数300+。不仅有学生参与其中，还吸引了当地其他学校的老师前来学习，给俊杰赚足了面子。在此也要感谢zhblue的开源项目hustoj(&lt;a href=&quot;https://github.com/zhblue/hustoj&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zhblue/hustoj&lt;/a&gt;)。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="总结" scheme="https://relish.wang/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://relish.wang/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Tips on MacOS</title>
    <link href="https://relish.wang/posts/17386/"/>
    <id>https://relish.wang/posts/17386/</id>
    <published>2018-12-23T04:34:03.000Z</published>
    <updated>2019-06-15T18:43:38.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在使用MacOS中的遇到的一些常见问题。记录下亲测有效的解决方案, 以备下次遇到相同的问题。</p><h2 id="一、HomeBrew"><a href="#一、HomeBrew" class="headerlink" title="一、HomeBrew"></a>一、HomeBrew</h2><h3 id="1-1-brew-update卡住问题"><a href="#1-1-brew-update卡住问题" class="headerlink" title="1.1 brew update卡住问题"></a>1.1 brew update卡住问题</h3><p><code>brew --repo</code>命令是打印HomeBrew的git地址。</p><p><strong>第一步</strong>:修改homebrew及homebrew-core的远程仓库地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># homebrew</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"># homebrew-core</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>第二步</strong>:执行<code>brew update</code></p><p><img src="/posts/17386/brew_update.png" alt="brew_update"></p><h2 id="二、在当前目录打开终端"><a href="#二、在当前目录打开终端" class="headerlink" title="二、在当前目录打开终端"></a>二、在当前目录打开终端</h2><p>1 系统偏好设置 -&gt; 键盘 -&gt; 快捷键 -&gt; 服务，勾选「新建位于文件夹位置的终端窗口」（后面的键盘快捷键可以不选）<br><img src="/posts/17386/terminal_tips.png" alt="config_it"></p><p>2 在 Finder 里面选中文件夹右键菜单的「服务」下面就会有「新建位于文件夹位置的终端窗口」这一子菜单了。</p><p><img src="/posts/17386/terminal_tips_show.png" alt="config_it"></p><p>参考资料: <a href="https://www.v2ex.com/t/81344" target="_blank" rel="noopener">《MAC OSX右键菜单能否添加类似于“在终端中打开当前目录”的快捷方式》</a></p><h2 id="三、打不开-xxx，因为它来自身份不明的开发者"><a href="#三、打不开-xxx，因为它来自身份不明的开发者" class="headerlink" title="三、打不开 xxx，因为它来自身份不明的开发者"></a>三、打不开 xxx，因为它来自身份不明的开发者</h2><p>修改系统配置：系统偏好设置 -&gt; 安全性与隐私 -&gt; 认证 -&gt; 修改为任何来源</p><p>如果没有此选项的，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><p><img src="/posts/17386/source_unknown_app.png" alt="来源不明的应用"></p><h2 id="四、制作MAC和Windows都支持U盘"><a href="#四、制作MAC和Windows都支持U盘" class="headerlink" title="四、制作MAC和Windows都支持U盘"></a>四、制作MAC和Windows都支持U盘</h2><p><font color="red"><strong>注:进行以下步骤前请先备份U盘内重要文件。</strong></font></p><p>第一步**：在MacOS上打开磁盘工具(使用<code>Sportlight 搜索</code>)</p><p><img src="/posts/17386/search_disk_tool.png" alt="search_disk_tool"></p><p>找不到<code>Sportlight 搜索</code>的读者请点击苹果电脑屏幕右上角的放大镜按钮<img src="/posts/17386/sportlight.png" alt="sportlight"></p><p><strong>第二步</strong>：抹掉U盘并选择<code>exFAT</code>格式的U盘</p><p><img src="/posts/17386/make_disk_exfat.gif" alt="make_disk_exfat"></p><p>完成！现在你的U盘在Windows和Mac都支持读写了！</p><p>参考资料: <a href="https://zhidao.baidu.com/question/1704119117672581620.html" target="_blank" rel="noopener">《如何让U盘同时兼容Windows和Mac OS X系统 》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;在使用MacOS中的遇到的一些常见问题。记录下亲测有效的解决方案, 以备下次遇到相同的问题。&lt;/p&gt;
&lt;h2 id=&quot;一、HomeBrew&quot;&gt;&lt;a href=&quot;#一、HomeBrew&quot; class=&quot;headerlink&quot; title=&quot;一、HomeBrew&quot;&gt;&lt;/a&gt;一、HomeBrew&lt;/h2&gt;&lt;h3 id=&quot;1-1-brew-update卡住问题&quot;&gt;&lt;a href=&quot;#1-1-brew-update卡住问题&quot; class=&quot;headerlink&quot; title=&quot;1.1 brew update卡住问题&quot;&gt;&lt;/a&gt;1.1 brew update卡住问题&lt;/h3&gt;&lt;p&gt;&lt;code&gt;brew --repo&lt;/code&gt;命令是打印HomeBrew的git地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;:修改homebrew及homebrew-core的远程仓库地址&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# homebrew&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd &amp;quot;$(brew --repo)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote set-url origin https://mirrors.ustc.edu.cn/brew.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# homebrew-core&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd &amp;quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="MacOS" scheme="https://relish.wang/categories/MacOS/"/>
    
    
      <category term="MacOS" scheme="https://relish.wang/tags/MacOS/"/>
    
      <category term="brew" scheme="https://relish.wang/tags/brew/"/>
    
      <category term="HomeBrew" scheme="https://relish.wang/tags/HomeBrew/"/>
    
      <category term="U盘" scheme="https://relish.wang/tags/U%E7%9B%98/"/>
    
      <category term="windows" scheme="https://relish.wang/tags/windows/"/>
    
      <category term="Mac" scheme="https://relish.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>AutoCompleteTextView最佳实践</title>
    <link href="https://relish.wang/posts/31830/"/>
    <id>https://relish.wang/posts/31830/</id>
    <published>2018-12-12T16:37:26.000Z</published>
    <updated>2019-06-15T18:43:37.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://raw.githubusercontent.com/relish-wang/AutoCompleteTextViewSample/master/art/banner.png" alt></p><p>此系列文章记录了一次使用AutoCompleteTextView(以下简称ACTV)的踩坑过程，并复盘整个的解决流程。</p><p>以下是此系列所有文章</p><ul><li><a href="https://github.com/relish-wang/AutoCompleteTextViewSample/blob/master/README.md" target="_blank" rel="noopener">《AutoCompleteTextView最佳实践-总集篇》</a></li><li><a href="https://github.com/relish-wang/AutoCompleteTextViewSample/blob/master/simplest_sample/README.md" target="_blank" rel="noopener">《AutoCompleteTextView最佳实践-最简例子篇》</a></li><li><a href="https://github.com/relish-wang/AutoCompleteTextViewSample/blob/master/doc/AutoComleteTextView最佳实践-原理剖析篇.md" target="_blank" rel="noopener">《AutoCompleteTextView最佳实践-原理剖析篇》</a></li><li><a href="https://github.com/relish-wang/KeyboardListener/blob/master/README.md" target="_blank" rel="noopener">《AutoCompleteTextView最佳实践-键盘事件篇》</a></li><li>《AutoCompleteTextView最佳实践-其他功能篇》(未完成)</li></ul><a id="more"></a><p><strong>关于作者</strong></p><blockquote><p>景三，程序员，主要从事Android平台基础架构方面的工作，欢迎交流技术方面的问题，可以去我的<a href="https://github.com/relish-wang" target="_blank" rel="noopener">Github</a>提issue或者发邮件至<a href="mailto:relish.wang@gmail.com" target="_blank" rel="noopener">relish.wang@gmail.com</a>与我交流。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/relish-wang/AutoCompleteTextViewSample/master/art/banner.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;此系列文章记录了一次使用AutoCompleteTextView(以下简称ACTV)的踩坑过程，并复盘整个的解决流程。&lt;/p&gt;
&lt;p&gt;以下是此系列所有文章&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/relish-wang/AutoCompleteTextViewSample/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《AutoCompleteTextView最佳实践-总集篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/relish-wang/AutoCompleteTextViewSample/blob/master/simplest_sample/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《AutoCompleteTextView最佳实践-最简例子篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/relish-wang/AutoCompleteTextViewSample/blob/master/doc/AutoComleteTextView最佳实践-原理剖析篇.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《AutoCompleteTextView最佳实践-原理剖析篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/relish-wang/KeyboardListener/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《AutoCompleteTextView最佳实践-键盘事件篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《AutoCompleteTextView最佳实践-其他功能篇》(未完成)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="UI" scheme="https://relish.wang/tags/UI/"/>
    
      <category term="[object Object]" scheme="https://relish.wang/tags/object-Object/"/>
    
  </entry>
  
  <entry>
    <title>精读《电梯调度算法》</title>
    <link href="https://relish.wang/posts/24587/"/>
    <id>https://relish.wang/posts/24587/</id>
    <published>2018-08-26T02:12:10.000Z</published>
    <updated>2019-06-15T18:43:38.232Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="精读《电梯调度算法》"><a href="#精读《电梯调度算法》" class="headerlink" title="精读《电梯调度算法》"></a>精读《电梯调度算法》</h2><p>文章地址：<a href="https://mp.weixin.qq.com/s/h_jlf9EAbE9dg7WJdiHKbg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/h_jlf9EAbE9dg7WJdiHKbg</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大家一定经历过等电梯的烦恼，尤其是在赶时间的时候，则更为头疼。如果你是一名程序员的话, 你一定有在等电梯时盘算过如何对电梯调度进行优化。</p><h2 id="常见调度算法简介"><a href="#常见调度算法简介" class="headerlink" title="常见调度算法简介"></a>常见调度算法简介</h2><p>文章对各种算法的介绍还算细致, 具体介绍了如何针对不同的情况对电梯的调度算法进行优化，使其能更高效地运作，但并未给出相应的代码。笔者不才，愿对其介绍的几种较易理解的非实时调度算法进行Java代码实现，权当抛砖引玉之效。献丑献丑。</p><a id="more"></a><h3 id="1-1-先来先服务算法-FCFS，FCFS-First-Come-First-Serve"><a href="#1-1-先来先服务算法-FCFS，FCFS-First-Come-First-Serve" class="headerlink" title="1.1 先来先服务算法(FCFS，FCFS-First Come First Serve)"></a>1.1 先来先服务算法(FCFS，FCFS-First Come First Serve)</h3><p>根据乘客请求乘坐电梯的先后次序进行调度。</p><p><strong>优点</strong>：</p><blockquote><p>公平、简单，且每个乘客的请求都能依次地得到处理，不会出现某一乘客的请求长期得不到满足的情况。</p></blockquote><p><strong>缺点</strong>：</p><blockquote><p>在载荷较大的情况下，这种算法的性能就会严重下降，甚至恶化。</p></blockquote><p><em>(缺点)举个例子</em>: 电梯处于1楼, A乘客请求从10楼到1楼，B乘客请求从1楼到10楼, C乘客请求从9楼到1楼。根据FCFS算法，电梯会先满足A乘客的请求，再满足B乘客的请求，最后满足C乘客的请求。</p><p><strong>代码</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一次任务请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> relish</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/08/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求所在楼层</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求去往楼层</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direct <span class="title">getDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from - to &gt; <span class="number">0</span> ? Direct.DOWN : Direct.UP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s %d-&gt;%d"</span>, name, from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运动方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Direct &#123;</span><br><span class="line">    UP,</span><br><span class="line">    DOWN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FCFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(List&lt;Task&gt; taskList, <span class="keyword">int</span> initPos)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1)先来先服务算法（FCFS）:"</span>);</span><br><span class="line">        System.out.format(<span class="string">"电梯当前位于第%s层, 对如下乘客进行服务:\n"</span>, initPos);</span><br><span class="line">        <span class="keyword">for</span> (Task task : taskList) &#123;</span><br><span class="line">            System.out.format(<span class="string">"%d-&gt;%d "</span>, task.from, task.to);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n请求次序     服务乘客    电梯移动楼层数"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = initPos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskList.size(); i++) &#123;</span><br><span class="line">            Task task = taskList.get(i);</span><br><span class="line">            <span class="keyword">int</span> abs = Math.abs(task.from - prev);</span><br><span class="line">            totalTime += abs;</span><br><span class="line">            <span class="keyword">int</span> d = Math.abs(task.from - task.to);</span><br><span class="line">            totalTime += d;</span><br><span class="line">            prev = task.to;</span><br><span class="line">            System.out.format(<span class="string">"   %d     %s:%2d-&gt;%2d       %2d\n"</span>, i, task.name, task.from, task.to, abs + d);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"总移动距离: "</span> + totalTime);</span><br><span class="line">        <span class="keyword">double</span> ave = totalTime / <span class="number">1.0</span> / taskList.size();</span><br><span class="line">        System.out.format(<span class="string">"平均每次服务的距离: %.1f\n"</span>, ave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>点评</strong>：代码简单。任务执行只需按请求队列的顺序执行即可。</p><p><img src="/posts/24587/FCFS.png" alt="FCFS"></p><h3 id="1-2-最短寻找楼层时间优先算法（SSTF，Shortest-Seek-Time-First）"><a href="#1-2-最短寻找楼层时间优先算法（SSTF，Shortest-Seek-Time-First）" class="headerlink" title="1.2 最短寻找楼层时间优先算法（SSTF，Shortest Seek Time First）"></a>1.2 最短寻找楼层时间优先算法（SSTF，Shortest Seek Time First）</h3><p>此算法选择下一个服务对象的原则是最短寻找楼层的时间。<br><strong>优点</strong>：</p><blockquote><p>注重电梯寻找楼层的优化。请求队列中距当前能够最先到达的楼层的请求信号就是下一个服务对象。</p></blockquote><p><strong>缺点</strong>：</p><blockquote><p>队列中的某些请求可能长时间得不到响应，出现所谓的“饿死”现象。</p></blockquote><p><em>(缺点)补充说明</em>: 处于中间楼层的请求会被快速响应，但处于底层和上层的请求，会被长时间搁置。</p><p><strong>代码</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSTF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(List&lt;Task&gt; taskList, <span class="keyword">int</span> initPos)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1)先来先服务算法（FCFS）:"</span>);</span><br><span class="line">        System.out.format(<span class="string">"电梯当前位于第%s层, 对如下乘客进行服务:\n"</span>, initPos);</span><br><span class="line">        <span class="keyword">for</span> (Task task : taskList) &#123;</span><br><span class="line">            System.out.format(<span class="string">"%d-&gt;%d "</span>, task.from, task.to);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n请求次序     服务乘客    电梯移动楼层数"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//---------------------调度开始-----------------------</span></span><br><span class="line">        <span class="keyword">int</span> prev = initPos;</span><br><span class="line">        List&lt;Task&gt; visit = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> shortIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; taskList.size(); j++) &#123;</span><br><span class="line">                Task task = taskList.get(j);</span><br><span class="line">                <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> curr = Math.abs(task.from - prev);</span><br><span class="line">                <span class="keyword">if</span> (min &gt; curr) &#123;</span><br><span class="line">                    min = curr;</span><br><span class="line">                    shortIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Task e = taskList.get(shortIndex);</span><br><span class="line">            visit.add(e);</span><br><span class="line">            taskList.set(shortIndex, <span class="keyword">null</span>);</span><br><span class="line">            prev = e.to;</span><br><span class="line">        &#125;</span><br><span class="line">        taskList.clear();</span><br><span class="line">        taskList.addAll(visit);</span><br><span class="line">      <span class="comment">//---------------------调度结束-----------------------      </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = initPos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskList.size(); i++) &#123;</span><br><span class="line">            Task task = taskList.get(i);</span><br><span class="line">            <span class="keyword">int</span> abs = Math.abs(task.from - prev);</span><br><span class="line">            totalTime += abs;</span><br><span class="line">            <span class="keyword">int</span> d = Math.abs(task.from - task.to);</span><br><span class="line">            totalTime += d;</span><br><span class="line">            prev = task.to;</span><br><span class="line">            System.out.format(<span class="string">"   %d     %s:%2d-&gt;%2d       %2d\n"</span>, i, task.name, task.from, task.to, abs + d);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"总移动距离: "</span> + totalTime);</span><br><span class="line">        <span class="keyword">double</span> ave = totalTime / <span class="number">1.0</span> / taskList.size();</span><br><span class="line">        System.out.format(<span class="string">"平均每次服务的距离: %.1f\n"</span>, ave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>点评</strong>: 与FCFS算法相比，SSTF算法会先对请求队列进行排序，每次都会优先处理距离最近的请求。</p><p><img src="/posts/24587/SSTF.png" alt="SSTF"></p><h3 id="1-3-扫描算法（SCAN）"><a href="#1-3-扫描算法（SCAN）" class="headerlink" title="1.3 扫描算法（SCAN）"></a>1.3 扫描算法（SCAN）</h3><p>扫描算法（SCAN）, 也被称为电梯调度算法，是一种按照楼层顺序依次服务请求，它让电梯在最底层和最顶层之间连续往返运行，在运行过程中响应处在于电梯运行方向相同的各楼层上的请求。</p><p><strong>优点</strong>:</p><blockquote><p>进行寻找楼层的优化，效率比较高。较好地解决了电梯移动的问题，在这个算法中，每个电梯响应乘客请求使乘客获得服务的次序是由其发出请求的乘客的位置与当前电梯位置之间的距离来决定的。</p></blockquote><p><strong>缺点</strong>:</p><blockquote><p>扫描算法的平均响应时间比最短寻找楼层时间优先算法长。</p></blockquote><p>扫描算法的响应时间方差比最短寻找楼层时间优先算法小，从统计学角度来讲，扫描算法要比最短寻找楼层时间优先算法稳定。</p><p><strong>代码</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SCAN</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"3)扫描算法（SCAN）:"</span>);</span><br><span class="line">        System.out.format(<span class="string">"电梯当前位于第%s层, 对如下乘客进行服务:\n"</span>, initPos);</span><br><span class="line">        <span class="keyword">for</span> (Task task : taskList) &#123;</span><br><span class="line">            System.out.format(<span class="string">"%d-&gt;%d "</span>, task.from, task.to);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n请求次序     服务乘客    电梯移动楼层数"</span>);</span><br><span class="line"><span class="comment">//---------------------调度开始-----------------------</span></span><br><span class="line">        List&lt;Task&gt; visit = <span class="keyword">new</span> ArrayList&lt;&gt;(taskList);</span><br><span class="line">        visit.sort(<span class="keyword">new</span> ScanComparator(initPos, direct));</span><br><span class="line">        taskList.clear();</span><br><span class="line">        taskList.addAll(visit);</span><br><span class="line"><span class="comment">//---------------------调度结束-----------------------</span></span><br><span class="line">        <span class="keyword">int</span> totalTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskList.size(); i++) &#123;</span><br><span class="line">            Task task = taskList.get(i);</span><br><span class="line">            <span class="keyword">int</span> d = Math.abs(task.from - task.to);</span><br><span class="line">            totalTime += d;</span><br><span class="line">            System.out.format(<span class="string">"   %d     %s:%2d-&gt;%2d       -\n"</span>, i, task.name, task.from, task.to);</span><br><span class="line">        &#125;</span><br><span class="line">        totalTime = (max - min) * <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"总移动距离: "</span> + totalTime);</span><br><span class="line">        <span class="keyword">double</span> ave = totalTime / <span class="number">1.0</span> / taskList.size();</span><br><span class="line">        System.out.format(<span class="string">"平均每次服务的距离: %.1f\n"</span>, ave);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SCAN算法任务排序(调度)比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScanComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Task</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initPos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Direct direct;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScanComparator</span><span class="params">(<span class="keyword">int</span> initPos, Direct direct)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initPos = initPos;</span><br><span class="line">        <span class="keyword">this</span>.direct = direct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Task o1, Task o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = ifInitDirectIsUp(o1, o2);</span><br><span class="line">        <span class="keyword">if</span> (direct == Direct.UP) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ifInitDirectIsUp</span><span class="params">(Task o1, Task o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = biggerOrSmaller(o1, o2);</span><br><span class="line">        Direct d1 = o1.getDirect();</span><br><span class="line">        Direct d2 = o2.getDirect();</span><br><span class="line">        <span class="keyword">if</span> (d1 == d2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d1 == Direct.UP) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.from &gt; initPos) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.from &gt; initPos) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (d1 == Direct.UP) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.from &gt; initPos) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.from &gt; initPos) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">biggerOrSmaller</span><span class="params">(Task o1, Task o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.from &gt; o2.from) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.from &lt; o2.from) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/24587/SCAN.png" alt="SCAN"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文章还介绍了其他两种非实时算法——<strong>LOOK算法</strong>和<strong>SATF算法</strong>。LOOK算法是对SCAN算法的改进，当判定继续往<em>上/下</em>走已经没有请求的楼层，便不会继续前行而是转向，而SCAN算法会继续运行到<em>顶/底</em>层再转向；SATF(Shortest Access Time First)算法与 SSTF 算法的思想类似，唯一的区别就是 SATF 算法将 SSTF 算法中的寻找楼层时间改成了访问时间。</p><p>文章还介绍了几种实时电梯调度算法。基本上是基于前面介绍的几种非实时调度算法的优化和改进。读者如有兴趣，可以对其进行深入研究，细细思考算法的精妙，还颇有趣味。</p><p>最后借用精读文章内的一句话来结束此文:  </p><blockquote><p>哪个算法都不是一个最佳方案，只是它确实解决了一定情况的问题。但是对一个优秀的程序员而言，研究各种算法是无比快乐的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;精读《电梯调度算法》&quot;&gt;&lt;a href=&quot;#精读《电梯调度算法》&quot; class=&quot;headerlink&quot; title=&quot;精读《电梯调度算法》&quot;&gt;&lt;/a&gt;精读《电梯调度算法》&lt;/h2&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://mp.weixin.qq.com/s/h_jlf9EAbE9dg7WJdiHKbg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/h_jlf9EAbE9dg7WJdiHKbg&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;大家一定经历过等电梯的烦恼，尤其是在赶时间的时候，则更为头疼。如果你是一名程序员的话, 你一定有在等电梯时盘算过如何对电梯调度进行优化。&lt;/p&gt;
&lt;h2 id=&quot;常见调度算法简介&quot;&gt;&lt;a href=&quot;#常见调度算法简介&quot; class=&quot;headerlink&quot; title=&quot;常见调度算法简介&quot;&gt;&lt;/a&gt;常见调度算法简介&lt;/h2&gt;&lt;p&gt;文章对各种算法的介绍还算细致, 具体介绍了如何针对不同的情况对电梯的调度算法进行优化，使其能更高效地运作，但并未给出相应的代码。笔者不才，愿对其介绍的几种较易理解的非实时调度算法进行Java代码实现，权当抛砖引玉之效。献丑献丑。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://relish.wang/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://relish.wang/tags/algorithm/"/>
    
      <category term="调度" scheme="https://relish.wang/tags/%E8%B0%83%E5%BA%A6/"/>
    
      <category term="算法" scheme="https://relish.wang/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从手写最简单的Android程序到Android Studio项目模板的全面解析</title>
    <link href="https://relish.wang/posts/24586/"/>
    <id>https://relish.wang/posts/24586/</id>
    <published>2018-06-24T12:25:30.000Z</published>
    <updated>2019-06-15T18:43:38.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></p><p>先上对比图(左侧是我们手动构建的最简单的Android项目;右侧是Android Studio默认创建的项目模板工程):</p><a id="more"></a><p><img src="/posts/24586/contrast_hand_and_template.png" alt="contrast_hand_and_template"></p><!-- more --><h2 id="0-序言"><a href="#0-序言" class="headerlink" title="0 序言"></a>0 序言</h2><p>  进入正题前，先说个与<strong>手写程序</strong>(不借助IDE)类似的场景。我回想起以前初学Java时的场景—— 如何用记事本写一个HelloWorld。    </p><ul><li><p>1 先写个最简单的Java程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello Java!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2 在当前目录下运行<code>javac A.java</code>(编译A.java文件，生成A.class文件)</p></li><li><p>3 在当前目录下运行<code>javac A</code>(执行class文件)</p></li><li><p>4 就会看到<code>Hello Java!</code>被打印在控制台(终端)上<br>  <img src="/posts/24586/exec_hello_java.png" alt="hello_java"></p></li></ul><p>用记事本开发Java程序确实简单，三两句话就讲完了。Android程序有那么多文件(<code>AndroidManifest.xml</code>、<code>启动的Activity</code>、<code>layout文件</code>、<code>icon图标</code>、<code>strings.xml</code>、<code>styles.xml文件</code>)，这可咋整啊？<br>要是你认同这句话, 说明你早就已经习惯于Android Studio为你生成的项目模板(以下简称”AS项目模板”), 而失去了作为一位Android开发者自我的判断——一个最简单的Android程序到底需要哪些文件。<br>AS项目模板(未在括号里标注的文件/文件夹都是gradle相关的, 下文会详细讲解):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── app(主工程)</span><br><span class="line">│   ├── app.iml(AS项目配置文件)</span><br><span class="line">│   ├── build(项目构建导出目录, 含apk)</span><br><span class="line">|   ├── build.gradle</span><br><span class="line">│   ├── libs(空文件夹)</span><br><span class="line">│   ├── proguard-rules.pro(混淆配置)</span><br><span class="line">│   └── src(源码)</span><br><span class="line">├── .gitignore(记录需要被git忽略的文件/文件夹)</span><br><span class="line">├── build</span><br><span class="line">├── build.gradle</span><br><span class="line">├── demo.iml(AS项目配置文件)</span><br><span class="line">├── gradle(文件夹)</span><br><span class="line">├── gradle.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── local.properties</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure><p>我可以告诉你, 上面所说的文件里，其实只有<strong>AndroidManifest.xml</strong>是必须的(图形页面对于Android程序来说并不是必须的, 比如<strong>只运行在后台的Service</strong>)。但是为了本文章的展示效果, 还是保留Activity。(有Activity也并不意味着一定需要layout.xml)</p><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1 准备"></a>1 准备</h2><p>前面丢了些悬念, 但我们还不能进入正题。先做或确保一些准备工作。<br>我们需要准备三样东西: <code>Java SDK</code>、<code>Android SDK</code>、<code>Gradle SDK</code> 。<br>前两样是Android开发必备的环境,  作为Android开发者自然不用多说。(请确保配置了ANDROID_HOME)<br>第三样是项目自动化构建工具(gradle), 可以用于构建Android项目。</p><h3 id="1-1-配置gradle"><a href="#1-1-配置gradle" class="headerlink" title="1.1 配置gradle"></a>1.1 配置gradle</h3><p>如果你是macOS用户, 只需执行一条命令即可配置好最新版本的gradle环境: <code>brew install gradle</code>;  如果你使用的是其他操作系统, 可以参看: <a href="https://gradle.org/install/" target="_blank" rel="noopener">https://gradle.org/install/</a><br>(确保配置了GRADLE_HOME)<br>配置完毕后运行<code>gradle -v</code>, 检查是否配置完成。<br> <img src="/posts/24586/gradle-v.png" alt="gradle-v"></p><h2 id="2-写一个最最简单的Android程序"><a href="#2-写一个最最简单的Android程序" class="headerlink" title="2 写一个最最简单的Android程序"></a>2 写一个最最简单的Android程序</h2><p>开门见山, 先放目录结构。需要手动编写的就三个文件<strong>MainActivity.java</strong>、<strong>AndroidManifest.xml</strong>、<strong>build.gradle</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">└─ src</span><br><span class="line">    ├─ main</span><br><span class="line">    │   ├─ java</span><br><span class="line">    │   │   └─ wang.relish.demo</span><br><span class="line">    │   │       └─ MainActivity.java</span><br><span class="line">    │   └─ AndroidManifest.xml</span><br><span class="line">    └─ build.gradle</span><br></pre></td></tr></table></figure><p><strong><code>MainActivity.java</code></strong> 内容如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.relish.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    TextView tv = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">    tv.setText(<span class="string">"Hello, beautiful world!"</span>);</span><br><span class="line">    setContentView(tv);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>AndroidManifest.xml</code></strong> 内容如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag"><span class="attr">package</span>=<span class="string">"wang.relish.demo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">applcation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activity</span> <span class="attr">anroid:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><code>build.gradle</code></strong> 内容如下:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.1.3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects&#123;</span><br><span class="line">    repositories&#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-生成项目的构建文件"><a href="#3-生成项目的构建文件" class="headerlink" title="3 生成项目的构建文件"></a>3 生成项目的构建文件</h2><p>接下来才是真正见证奇迹的时刻。<br>在<code>demo</code>(项目根目录)下执行<code>gradle assemble</code>, 如果你看到下图的执行结果说明运行成功了, 可以略过下文的错误说明, 请看<a href="#执行完成">执行完成</a>。<img src="/posts/24586/gradle_assemble.png" alt="gradle_assemble"><br>如果你遇到如下错误, 则说明你未配置<code>ANDROID_HOME</code>环境变量。<br><img src="/posts/24586/without_android_home.png" alt="without_andrid_home"><br>解决方案有二:</p><ul><li>1)  配置ANDROID_HOME环境变量。下图是笔者电脑上的配置:<br><img src="/posts/24586/android_home.png" alt="android_home"></li><li>2) 在demo(项目根目录)下新建<code>local.properties</code>文件, 输入AndroidSDK所在路径：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk.dir=/Users/relish/Library/Android/sdk</span><br></pre></td></tr></table></figure></li></ul><p>下图是笔者电脑上的配置:<br>  <img src="/posts/24586/local_properties.png" alt="local_properties"></p><h3 id="执行完成"><a href="#执行完成" class="headerlink" title="执行完成"></a>执行完成</h3><p>执行完成后目录结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── .gradle(gradle任务相关缓存)</span><br><span class="line">├── build(执行assemble命令后生成的文件, apk文件也在这里面)</span><br><span class="line">├── build.gradle</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── wang.relish.demo</span><br><span class="line">        │       └── MainActivity.java</span><br><span class="line">        └── AndroidManifest.xml</span><br></pre></td></tr></table></figure><p>在<code>/build/outputs/apk</code>的<code>debug</code>和<code>release</code>文件下就可以看到生成的apk文件了。<br>安装apk文件后,  桌面图标如下(不同Android版本上显示的默认logo不同)：<br> <img src="/posts/24586/desktop_icon.png" alt="desktop_icon"><br>运行可以看到如下画面：<br> <img src="/posts/24586/mainactivity.jpg" alt="mainactivity"></p><p>也许看到这里的读者开始有些疑问了。为什么只要这么三个文件就够了？哪怕构建后也只多了两个文件夹？AndroidStudio生成的空项目里还有<code>setting.gradle</code>、<code>.idea</code>文件夹、<code>gradle</code>文件夹、<code>*.iml</code>文件、<code>gradlew</code>、<code>gradlew.bat</code>等, 这么多文件呢!</p><h2 id="4-由简入繁"><a href="#4-由简入繁" class="headerlink" title="4 由简入繁"></a>4 由简入繁</h2><p>如果你觉得这篇文章就这么结束了, 那你就想得太简单了。<br>莫慌, 正片开始!  接下来我要讲的是, 这个项目如何一步一步转化为我们熟悉的AndroidStudio的默认创建项目。</p><h3 id="4-1-Gradle-Wrapper"><a href="#4-1-Gradle-Wrapper" class="headerlink" title="4.1 Gradle Wrapper"></a>4.1 Gradle Wrapper</h3><p>Gradle Wrapper是对Gradle的一层包装, 便于团队开发过程中统一Gradle构建的版本。 我们在项目开发过程中, 用的都是Wrapper这种方式。所以前面用的gradle相关命令建议都改为gradlew的命令(如:  <code>gradle assemble</code>改为<code>./gradlew assemble</code>)。  </p><p>在<code>demo</code>(项目根目录)下执行<code>gradle wrapper</code>, 执行完成后目录结构下<strong>新增</strong>的文件/文件夹如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├─ gradle</span><br><span class="line">│  └─ wrapper</span><br><span class="line">│     ├─ gradle-wrapper.jar</span><br><span class="line">│     └─ gradle-wrapper.properties</span><br><span class="line">├─ gradlew</span><br><span class="line">└─ gradlew.bat</span><br></pre></td></tr></table></figure><p><code>gradlew</code>和<code>gradlew.bat</code>分别是Linux和Windows下的可执行脚本。<br><code>gradle-wrapper.jar</code>是具体业务逻辑实现的jar包。gradlew最终是使用这个jar包来执行相关的Gradle操作。<br><code>gradle-wrapper.properties</code>是配置文件, 用于配置使用哪个版本的Gradle等。  </p><p>打开<code>gradle-wrapper.properties</code>文件, 可以看到以下内容:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper<span class="regexp">/dists</span></span><br><span class="line"><span class="regexp">distributionUrl=https\:/</span><span class="regexp">/services.gradle.org/</span>distributions<span class="regexp">/gradle-4.8-bin.zip</span></span><br><span class="line"><span class="regexp">zipStoreBase=GRADLE_USER_HOME</span></span><br><span class="line"><span class="regexp">zipStorePath=wrapper/</span>dists</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">字段名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">distributionBase</td><td align="left">下载的Gradle压缩包解压后储存的主目录</td></tr><tr><td align="left">distributionPath</td><td align="left">相对于distributionBase的解压后的Gradle压缩包的路径</td></tr><tr><td align="left">zipStoreBase</td><td align="left">同distributionBase， 只不过是存放zip压缩包的</td></tr><tr><td align="left">zipStorePath</td><td align="left">同distributionPath， 只不过是存放zip压缩包的</td></tr><tr><td align="left">distributionUrl</td><td align="left">Gradle发型版压缩包的下载地址</td></tr><tr><td align="left">这里我们基本只需关注<code>distributionUrl</code>即可, 这个字段决定了你的gradle wrapper依赖哪个gradle版本。</td><td align="left"></td></tr></tbody></table><ul><li>为什么要使用Wrapper?使用Wrapper有什么好处?  <blockquote><p>因为使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。而且假设每个开发者电脑上未安装/配置gradle环境, 那么他/她仍能通过执行gradlew命令执行gradle相关任务。而且wrapper规定了使用的gradle版本, 在团队开发中, 执行gradlew命令运行的都是同一个版本的gradle。避免了每个团队成员电脑上配置的gradle版本不同而带来的执行结果的差异。</p></blockquote></li></ul><h3 id="4-2-多工程配置"><a href="#4-2-多工程配置" class="headerlink" title="4.2 多工程配置"></a>4.2 多工程配置</h3><h4 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h4><p>到这里为止, 先来看一下我们项目的目录结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├─ .gradle(文件夹)</span><br><span class="line">├─ build(文件夹, 可删)</span><br><span class="line">├─ gradle(文件夹)</span><br><span class="line">├─ gradlew</span><br><span class="line">├─ gradlew.bat</span><br><span class="line">├─ build.gradle</span><br><span class="line">├─ local.properties(可选)</span><br><span class="line">└─ src</span><br><span class="line">    └─ main</span><br><span class="line">       ├─ java</span><br><span class="line">       │   └─ wang.relish.demo</span><br><span class="line">       │      └─ MainActivity.java</span><br><span class="line">       └─ AndroidManifest.xml</span><br></pre></td></tr></table></figure><p>仔细观察发现, 少了<code>settings.gradle</code>文件,  而且这个<code>src</code>目录外面应该再包一层<code>app</code>目录…即便这样<code>app</code>里也少了一些其他的文件…莫慌, 我们一点点来分析。  </p><p><code>settings.gradle</code>文件大多数的作用是为了配置子工程(moudle)。但由于我们这个”最简单的Android程序”是一个单工程的项目, 所以<code>settings.gradle</code>并不是必须的。但是, 在实际开发过程中, 项目(Project)大多为多工程(module), 因此AS项目模板是会默认配置好<code>settings.gradle</code>, 并且主工程也被包装成一个名为<code>app</code>的子工程(moudle)。  </p><p><code>settings.gradle</code>的内容也很简单:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">':app'</span></span><br></pre></td></tr></table></figure><p>如果有多个module则用逗号隔开(不过我们这次不需要):</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">':app'</span>, <span class="string">':module1'</span>, <span class="string">':module2'</span></span><br></pre></td></tr></table></figure><h4 id="子工程配置"><a href="#子工程配置" class="headerlink" title="子工程配置"></a>子工程配置</h4><p>在<code>demo</code>(项目根目录)下, 新建<code>app</code>文件夹，将<code>demo</code>(项目根目录)下的<strong>src文件夹</strong>和<code>build.gradle</code>移动/剪切到新建的<code>app</code>目录下。  </p><p>这时再次执行<code>./gradlew assemble</code>, 已经可以生成apk文件了。但总觉得还是跟AS项目模板有些不同——根目录少了一个build.gradle文件。此时的工程目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├─ .gradle(文件夹)</span><br><span class="line">├─ gradle(文件夹, 含wrapper配置)</span><br><span class="line">├─ gradlew</span><br><span class="line">├─ gradlew.bat</span><br><span class="line">├─ local.properties(可选)</span><br><span class="line">├─ settings.gradle(多工程配置)</span><br><span class="line">└─ app</span><br><span class="line">   ├─ build.gradle(从根目录移动进来的)   </span><br><span class="line">   └─ src(源码文件夹)</span><br></pre></td></tr></table></figure><p>既然是多工程配置, 那么每个子工程(module)都需要的配置就可以做成项目(project)配置, 减少重复代码。</p><p>因此我们把<code>./app/build.gradle</code>内的部分内容移动到根目录下的<code>build.gradle</code>中。</p><p>./build.gradle内容:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123; <span class="comment">// 一个在项目构建之前, 为项目进行前期准备和初始化相关配置依赖的地方</span></span><br><span class="line">    repositories &#123; 配置需要依赖的gradle插件所在的仓库地址</span><br><span class="line">        jcenter()</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123; <span class="comment">// 配置需要依赖的gradle插件</span></span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.1.3'</span> <span class="comment">// Android Gradle 插件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects&#123;</span><br><span class="line">    repositories&#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>./app/build.gradle内容:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到根目录下的build.gradle已经和AS项目模板长得很像了, 区别在与下面这段代码:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task clean(<span class="string">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个名为clean的gradle任务(task)，我们可以通过运行<code>./gradlew clean</code>执行这个任务。它的执行结果就是删除主项目的build文件夹。</p><p>忘了说, 现在再执行<code>./gradlew assemble</code>, <code>build</code>文件夹会生成在<code>app</code>目录下。再执行<code>./gradlew clean</code>就会删除<code>app</code>目录下的<code>build</code>文件夹。</p><h3 id="4-3-其他未介绍的文件"><a href="#4-3-其他未介绍的文件" class="headerlink" title="4.3 其他未介绍的文件"></a>4.3 其他未介绍的文件</h3><p>其实文章讲解到这里, 我们手动修改的项目已经和AS项目模板大致相同了。因为此文介绍的重点其实是<em>gradle构建工具</em>和<em>一个最简单的Android项目需要那些文件</em>。但鉴于这里还有一些文件未提及，笔者决定简单介绍一下它们。</p><table><thead><tr><th align="left">文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*.iml、.idea文件夹</td><td align="left">JetBrain家的IDEA系列IDE的项目配置文件(Android Studio是基于IntelliJ IDEA的), 可以删除,下次用Android Studio打开时会自动生成</td></tr><tr><td align="left">gradle.properties</td><td align="left">可以放置gradle相关的全局常量声明和项目运行内存设置等</td></tr><tr><td align="left">local.properties</td><td align="left">声明AndroidSDK和NDK所在路径</td></tr><tr><td align="left">app/proguard-rules.pro</td><td align="left">代码混淆配置</td></tr><tr><td align="left">app/libs</td><td align="left">存放jar/aar包</td></tr><tr><td align="left">.gitignore、app/.gitignore</td><td align="left">记录需要被git忽略的文件/文件夹</td></tr></tbody></table><p><code>.gitignore</code>文件通常需要填写的内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.gradle/</span><br><span class="line">.idea/</span><br><span class="line">build/</span><br><span class="line">*.iml</span><br><span class="line">local.properties</span><br></pre></td></tr></table></figure><p>app/.gitignore文件通常需要填写的内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build/</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><h2 id="5-app主工程"><a href="#5-app主工程" class="headerlink" title="5 app主工程"></a>5 app主工程</h2><p>文章讲解到这里,  我们手动修改的项目和AS项目模板的区别剩下app(主工程目录)目录下的文件内容、目录结构不同了。<br><img src="/posts/24586/contrast_hand_and_template.png" alt="contrast_hand_and_template"></p><p>二者不同的地方都已经用黄框和蓝框标出来了。其中黄框标注的文件已经在前文介绍过它们的作用了。下面介绍一下蓝框里的文件/文件夹。</p><h3 id="5-1-单元测试"><a href="#5-1-单元测试" class="headerlink" title="5.1 单元测试"></a>5.1 单元测试</h3><p><code>androidTest</code>文件夹和<code>test</code>文件夹分别是Android单元测试和Java单元测试相关的目录。AS模板项目所用的单元测试框架是Java单元测试框架<a href="https://junit.org/junit5/" target="_blank" rel="noopener">junit</a>、<a href="https://developer.android.com/reference/android/support/test/runner/AndroidJUnit4" target="_blank" rel="noopener">AndroidJUnit</a>、Android UI自动化测试框架<a href>espresso</a>。</p><p>由于篇幅原因，关于<strong>单元测试</strong>的用法就不在此文中详细描述，感兴趣的读者可以查阅文末的引用资料或自行搜索相关资料进行学习。</p><h3 id="5-2-资源文件"><a href="#5-2-资源文件" class="headerlink" title="5.2 资源文件"></a>5.2 资源文件</h3><p>所有的资源文件夹都有<code>-v[api-level]</code>的形式、<code>-[各国语言缩写]</code>国际化资源的形式。如:<code>drawable-zh-ldpi</code>、<code>values-en</code>、<code>drawable-v21</code>。</p><h4 id="drawable"><a href="#drawable" class="headerlink" title="drawable"></a>drawable</h4><p>存放图片/图标文件以及样式相关的文件</p><table><thead><tr><th align="left">文件夹</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">drawable</td><td align="left">放置selector、shape、vector文件</td></tr><tr><td align="left">drawable-mdpi</td><td align="left">中分辨率图标(72*72, 320*480)</td></tr><tr><td align="left">drawable-hdpi</td><td align="left">高分辨率图标(尺寸标准:48*48, 对应手机分辨率:480*800)</td></tr><tr><td align="left">drawable-xhdpi</td><td align="left">超高分辨率图标(96*96, 720*1280)</td></tr><tr><td align="left">drawable-xxhdpi</td><td align="left">超超高分辨率图标(144*144, 1080*1920), 主流分辨率</td></tr><tr><td align="left">drawable-xxxhdpi</td><td align="left">超超超高分辨率图标(192*192, 3840*2160)</td></tr><tr><td align="left">drawable-v19</td><td align="left">Android4.4(API19)及以上特别设置的样式/图标</td></tr><tr><td align="left">drawable-v21</td><td align="left">Android5.0(API21)及以上特别设置的样式/图标</td></tr><tr><td align="left">drawable-v24</td><td align="left">Android7.0(API24)及以上特别设置的样式/图标</td></tr></tbody></table><p>drawable-v[API-version]: 此类文件夹下的同名图标会默认使用最高版本的。如: <code>ic_avatar.png</code>分别在<code>drawable-v19</code>和<code>drawable-v21</code>分别有两个长得不同的图标文件, 如果运行的手机是Android5.1(API22)的, 那么它会加载<code>drawable-v21</code>下的<code>ic_avatar.png</code>;但如果仅在<code>drawable-v19</code>下放置了<code>ic_avatar.png</code>，<code>drawable-v21</code>没有的话, 在这台手机上运行时就会加载<code>drawable-v19</code>下的<code>ic_avatar.png</code>;如果drawable-v[API-version]此类文件夹未放置<code>ic_avatar.png</code>图标, 则会加载对应分辨率文件夹下的<code>ic_avatar.png</code>; 要是各分辨率的文件夹里也没有<code>ic_avatar.png</code>的话，就会加载<code>drawable</code>文件夹下的<code>ic_avatar.png</code>。</p><p>图标加载顺序:</p><p><code>drawable-v[对应的高API]</code>-&gt;<code>drawble-v[低API]</code>-&gt;<code>drawable-[对应高分辨率]dpi</code>-&gt;<code>drawable-[低分辨率]dpi</code>-&gt;<code>drawable</code></p><h4 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h4><table><thead><tr><th align="left">文件夹</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">layout</td><td align="left">默认加载的布局文件</td></tr><tr><td align="left">layout-land</td><td align="left">横屏时加载的布局文件</td></tr><tr><td align="left">layout-port</td><td align="left">竖屏时加载的布局文件</td></tr><tr><td align="left">布局文件加载顺序:</td><td align="left"></td></tr><tr><td align="left">(根据屏幕状态而定)<code>layout-land</code>或<code>layout-port</code>-&gt;<code>layout</code></td><td align="left"></td></tr></tbody></table><h4 id="mipmap"><a href="#mipmap" class="headerlink" title="mipmap"></a>mipmap</h4><p>用法与drawable一致。区别在于: mipmap文件夹仅仅用于放置app的logo图标。</p><h4 id="values"><a href="#values" class="headerlink" title="values"></a>values</h4><p>AS项目模板:</p><table><thead><tr><th align="left">文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">colors.xml</td><td align="left">颜色值常量</td></tr><tr><td align="left">strings.xml</td><td align="left">字符串常量</td></tr><tr><td align="left">styles.xml</td><td align="left">样式常量</td></tr></tbody></table><p>除此之外还可以有以下文件:</p><table><thead><tr><th align="left">文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ids.xml</td><td align="left">id常量(int类型)</td></tr><tr><td align="left">arrays.xml</td><td align="left">数组常量</td></tr><tr><td align="left">attrs.xml</td><td align="left">属性声明, 用于自定义View</td></tr><tr><td align="left">dimens.xml</td><td align="left">尺寸常量。长度(dp)、字体大小(sp)、像素值(px)等</td></tr><tr><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>其实并不需要拘泥于这些文件名, 想取啥文件名都行, 甚至这些文件里的内容也可以全写在一个文件里(但推荐写法还是分开写, 各司其职):</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- from arrays.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string-array</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>女<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>男<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">string-array</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- from attrs.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"customView"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"customAttr"</span> <span class="attr">format</span>=<span class="string">"string"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- from colors.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- from dimen.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"title_text_size"</span>&gt;</span>16sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- from strings.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- from styles.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="其他资源文件"><a href="#其他资源文件" class="headerlink" title="其他资源文件"></a>其他资源文件</h4><p>这里还有一些常见资源文件/文件夹未提及, 将在下方表格中列出:</p><table><thead><tr><th align="left">文件夹</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">anim</td><td align="left">动画文件</td></tr><tr><td align="left">raw</td><td align="left">媒体文件(音频、视频文件)</td></tr><tr><td align="left">xml</td><td align="left">其他的xml类型文件</td></tr><tr><td align="left">menu</td><td align="left">菜单文件</td></tr></tbody></table><h3 id="5-3-app-build-gradle"><a href="#5-3-app-build-gradle" class="headerlink" title="5.3 app/build.gradle"></a>5.3 app/build.gradle</h3><p>AS项目模板的<code>app/build.gradle</code>文件内容:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span> <span class="comment">// 应用Android Gradle插件. (有些网友在介绍gradle的文章中把它描述为"声明是Android程序",纯属扯淡)</span></span><br><span class="line"></span><br><span class="line">android &#123; <span class="comment">// Android Gradle插件为Project对象添加的一个拓展</span></span><br><span class="line">    compileSdkVersion <span class="number">26</span> <span class="comment">// 编译版本</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"wang.relish.demo"</span> <span class="comment">// 应用包名</span></span><br><span class="line">        minSdkVersion <span class="number">14</span> <span class="comment">// 此app允许运行的最低的API版本的手机</span></span><br><span class="line">        targetSdkVersion <span class="number">26</span> <span class="comment">// 允许使用新特性的最高版本。也就是说API27及以上的手机也能安装这个app, 但仅仅有API26及以下的新特性</span></span><br><span class="line">        versionCode <span class="number">1</span>  <span class="comment">// app版本编号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span> <span class="comment">// app版本号。其实就是个字符串叫啥都可以。业内统一使用xxx.xxx.xxx的形式。</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span> <span class="comment">// 单元测试: AndroidJUnit</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 是否进行混淆</span></span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 混淆文件的位置</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; <span class="comment">// 声明依赖</span></span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>]) <span class="comment">// 位于app/libs/下的jar包依赖</span></span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:26.1.0'</span></span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.1.2'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span> <span class="comment">// 单元测试：junit</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:1.0.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.2'</span> <span class="comment">// AndroidUI自动化测试框架</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="implementation-vs-compile"><a href="#implementation-vs-compile" class="headerlink" title="implementation vs compile"></a>implementation vs compile</h4><p>从<code>Android Gradle plugin 3.0</code>开始推荐使用<code>implementation</code>和<code>api</code>来替换原先的<code>compile</code>。理论上你可以把所有的<code>compile</code>替换成<code>api</code>。下面说说它们的区别:</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">compile</td><td align="left">本module将会泄露其依赖的module的内容</td></tr><tr><td align="left">api</td><td align="left">同compile</td></tr><tr><td align="left">implementation</td><td align="left">本module不会通过自身的接口向外部暴露其依赖module的内容。推荐使用implementation来进行依赖(而不是api或compile),这会大大改善工程的构建时间</td></tr></tbody></table><p>其他改动:</p><ul><li>provided -&gt; compileOnly</li><li>apk -&gt; runtimeOnly</li><li>testCompile -&gt; testImplementation // 编译测试用例时依赖, 不会打包到发布的产品中</li><li>androidTestCompile -&gt; androidTestImplementation // 编译测试用例时依赖, 不会打包到发布的产品中</li></ul><h3 id="5-4-AndroidManifest-xml"><a href="#5-4-AndroidManifest-xml" class="headerlink" title="5.4 AndroidManifest.xml"></a>5.4 AndroidManifest.xml</h3><p>AS项目模板的<code>AndroidManifest.xml</code>文件内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"wang.relish.demo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span> // <span class="attr">app</span>桌面<span class="attr">logo</span>。不设置的话是<span class="attr">Android</span>系统自带的图标(不同<span class="attr">Android</span>版本长得不同)。</span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> // <span class="attr">App</span>名。不设置的话, 默认为启动的<span class="attr">Activity</span>的全类名</span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span> // <span class="attr">Android</span> <span class="attr">O</span> 新特性, 原型图标</span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>本来只是想介绍一个<strong>不借助IDE可以手写出来的最简单的Android程序</strong>的教程。讲着讲着就想把Android Studio的模板工程目录结构、文件作用都说了一遍, 不知不觉写了这么多。也把我们这个最简单的Android程序一步步拓展成了Android Studio的模板工程。希望各位读者在体会到Android Studio为我们广大Android开发者的开发工作带来莫大的帮助的同时, 明白Android Studio为我们都做了哪些事。</p><h2 id="引用资料"><a href="#引用资料" class="headerlink" title="引用资料"></a>引用资料</h2><p>Wrapper (gradlew): </p><blockquote><p><a href="https://www.zybuluo.com/xtccc/note/275168" target="_blank" rel="noopener">https://www.zybuluo.com/xtccc/note/275168</a>  </p></blockquote><p>Gradle官方文档:</p><blockquote><p><a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">https://docs.gradle.org/current/dsl/index.html </a>  </p></blockquote><p>Android单元测试-如何开始?</p><blockquote><p><a href="https://www.jianshu.com/p/bc99678b1d6e" target="_blank" rel="noopener">https://www.jianshu.com/p/bc99678b1d6e</a></p></blockquote><p>自适应图标(Adaptive icons):</p><blockquote><p><a href="https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive" target="_blank" rel="noopener">https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive</a></p></blockquote><p>迁移到插件3.0.0:</p><blockquote><p><a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration#new_configurations" target="_blank" rel="noopener">https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration#new_configurations</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;先上对比图(左侧是我们手动构建的最简单的Android项目;右侧是Android Studio默认创建的项目模板工程):&lt;/p&gt;
    
    </summary>
    
      <category term="Android Studio" scheme="https://relish.wang/categories/Android-Studio/"/>
    
    
      <category term="Android Studio" scheme="https://relish.wang/tags/Android-Studio/"/>
    
      <category term="Template" scheme="https://relish.wang/tags/Template/"/>
    
      <category term="gradle" scheme="https://relish.wang/tags/gradle/"/>
    
      <category term="gradlew" scheme="https://relish.wang/tags/gradlew/"/>
    
  </entry>
  
  <entry>
    <title>refusing to merge unrelated histories</title>
    <link href="https://relish.wang/posts/49348/"/>
    <id>https://relish.wang/posts/49348/</id>
    <published>2018-03-14T03:13:32.000Z</published>
    <updated>2020-01-19T01:50:46.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="合并起源不同的git分支-合并两个git仓库"><a href="#合并起源不同的git分支-合并两个git仓库" class="headerlink" title="合并起源不同的git分支(合并两个git仓库)"></a>合并起源不同的git分支(合并两个git仓库)</h1><p>关键命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch] --allow-unrelated-histories</span><br></pre></td></tr></table></figure><p>背景: 我和好友分别维护着一份PAT题解相关的repository, 区别是她使用的是JS代码，我使用的是Java(偶尔会用C/C++、python等)(PS:欢迎使用各种语言的各路大佬加入我们的repo)。后来我们一拍即合,决定合成一个repository。</p><a id="more"></a><p><img src="/posts/49348/coding.gif" alt="pat"><br>想法是这样的，我fork她的repository，commit &amp; push我的代码后，再发起pull request交由她处理，并合入她的repository的主分支。那么问题来了，我确实可以复制粘贴我的代码，然后提交后发起pull request。但是这样做的话，我之前的commit记录都会消失。我更希望能够<strong>保留我的commit记录</strong>。</p><p><img src="/posts/49348/fork.gif" alt="fork"></p><h2 id="1-导入旧仓库的git记录"><a href="#1-导入旧仓库的git记录" class="headerlink" title="1 导入旧仓库的git记录"></a>1 导入旧仓库的git记录</h2><p>一般情况下只需要像上图描述的步骤进行就行了。如果要保留旧仓库的commit记录，那就需要在2、3两步之间多加一些步骤。</p><h3 id="1-1-将源地址设置为旧仓库的地址"><a href="#1-1-将源地址设置为旧仓库的地址" class="headerlink" title="1.1 将源地址设置为旧仓库的地址"></a>1.1 将源地址设置为旧仓库的地址</h3><blockquote><p>git remote set-url origin <a href="https://github.com/relish-wang/PAT.git" target="_blank" rel="noopener">https://github.com/relish-wang/PAT.git</a></p></blockquote><h3 id="1-2-拉取代码-解决冲突并合并"><a href="#1-2-拉取代码-解决冲突并合并" class="headerlink" title="1.2 拉取代码,解决冲突并合并"></a>1.2 拉取代码,解决冲突并合并</h3><p>直接<code>git pull</code>的话,会出现这样的错误：<strong>拒绝合并无关的历史记录</strong>。这是为什么呢？因为一般来说一个git仓库的起源肯定是一个点。而这次合并会产生两个起源点(一个是我的旧仓库的master的起源点，另一个是她的旧仓库的master分支的起源点)。<br><img src="/posts/49348/merge.png" alt="merge"><br>这就用到了下面这个命令: <strong>允许合并无关的历史记录</strong></p><blockquote><p>git pull origin master –allow-unrelated-histories</p></blockquote><p>合并后的git记录树:<br><img src="/posts/49348/gitmerge.gif" alt="gitmerge"></p><p>然后就可以发起pull request了。</p><p><img src="/posts/49348/newflow.gif" alt="newflow"></p><h2 id="2-用Intellij-IDEA打开项目-并运行Java文件"><a href="#2-用Intellij-IDEA打开项目-并运行Java文件" class="headerlink" title="2 用Intellij IDEA打开项目,并运行Java文件"></a>2 用Intellij IDEA打开项目,并运行Java文件</h2><p>上述步骤完成后，意外地发现IDEA无法识别这个项目里的java文件了。<br><img src="/posts/49348/red.png" alt="red"><br>而能运行的java文件长这样：<br><img src="/posts/49348/green.png" alt="green"></p><h3 id="2-1-修改项目配置"><a href="#2-1-修改项目配置" class="headerlink" title="2.1 修改项目配置"></a>2.1 修改项目配置</h3><p>使用快捷键<code>Command+;</code>打开。下图是正确的配置。<br><img src="/posts/49348/configjava.png" alt="javaconfig"><br>修改后发现，仍未解决问题。</p><h3 id="2-2-修改moudle配置"><a href="#2-2-修改moudle配置" class="headerlink" title="2.2 修改moudle配置"></a>2.2 修改moudle配置</h3><p>安装下面如图所示的步骤操作后，就完成了！</p><p><img src="/posts/49348/step1.gif" alt="step1"><br><img src="/posts/49348/step2.gif" alt="step2"><br><img src="/posts/49348/step3.gif" alt="step3"><br><img src="/posts/49348/step4.gif" alt="step4"></p><h2 id="3-最后说几句"><a href="#3-最后说几句" class="headerlink" title="3 最后说几句"></a>3 最后说几句</h2><p>欢迎使用各种语言的各路大佬加入我们的repo。项目地址:<a href="http://github.com/taryn2016/coding" target="_blank" rel="noopener">http://github.com/taryn2016/coding</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合并起源不同的git分支-合并两个git仓库&quot;&gt;&lt;a href=&quot;#合并起源不同的git分支-合并两个git仓库&quot; class=&quot;headerlink&quot; title=&quot;合并起源不同的git分支(合并两个git仓库)&quot;&gt;&lt;/a&gt;合并起源不同的git分支(合并两个git仓库)&lt;/h1&gt;&lt;p&gt;关键命令&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git pull origin master --allow-unrelated-histories&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;或&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git merge [branch] --allow-unrelated-histories&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;背景: 我和好友分别维护着一份PAT题解相关的repository, 区别是她使用的是JS代码，我使用的是Java(偶尔会用C/C++、python等)(PS:欢迎使用各种语言的各路大佬加入我们的repo)。后来我们一拍即合,决定合成一个repository。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://relish.wang/categories/git/"/>
    
    
      <category term="git" scheme="https://relish.wang/tags/git/"/>
    
      <category term="pull request" scheme="https://relish.wang/tags/pull-request/"/>
    
      <category term="fork" scheme="https://relish.wang/tags/fork/"/>
    
  </entry>
  
  <entry>
    <title>什么2017还是看2018</title>
    <link href="https://relish.wang/posts/45704/"/>
    <id>https://relish.wang/posts/45704/</id>
    <published>2018-02-26T13:28:05.000Z</published>
    <updated>2019-06-15T18:43:38.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么2017还是看2018"><a href="#什么2017还是看2018" class="headerlink" title="什么2017还是看2018"></a>什么2017还是看2018</h1><p>去年年末看到好多小伙伴在写年终总结，有关生活的，有关工作的，对来年(2018)的展望的，没有丝毫的想法，不知怎的没有动笔的冲动。直到今天(开年第一天上班)，头哥给大伙开了个会，讲了很多关于工作上的规划和以及每个人在团队里的定位，内容很多，并不能完全消化，但确实给了我很大的启发，让我动了写这篇总结的念头。</p><p>其实我一直是个有规划的人，大学四年的所有资料、文档、代码，我都会挨个儿根据科目、学期分文件夹。这一次，也要细细来讲，但并不想确保条理清晰。</p><p>虽然说是2017-2018，其实应该是2017的春节-2018的春节。那么，开始吧。</p><a id="more"></a><p><strong>2017.3中</strong><br>带着刚毕业的傲气，仗着笔试题简单，拿了个高分；面试时说话，人就有点飘了，还班门弄斧地“指点”了大风车的热补丁方案。现在想想真是蠢。因为当时的面试官就是我现在的师父。总觉得我那种绣花枕头一包草的形象已经在我师父眼里根深蒂固了。每每想到此处，都想跳槽跑路，真是没脸待下去了。</p><p><strong>2017.3下</strong><br>入职时刚好是无线部拆分成<strong>无线业务部</strong>和<strong>无线架构部</strong>的时候，当时还不知道有什么区别也不知道自己被分在架构部。后来才知道架构部都是大佬(除了我)，一般来说p级都是比业务组要高的。（后来还从测试同学那听来，测试同学都不太会给架构组同学提bug，因为都是大佬，说话都是恭恭敬敬的。）<br><img src="https://user-images.githubusercontent.com/20558748/36674947-8f35d51e-1b42-11e8-86ba-23191e8201d3.png" alt="黑人问号"><br>那我可能是个假人。</p><p>刚入职可能想展现一下实力吧。师父给了我一个日期范围选择控件(自定义View)任务, 本来给了两周时间，结果我3天就完成了基本功能。但师父似乎并不怎么满意。后来证明，确实可扩展性太差了，业务组的小伙伴也反应这个组件太难用。这又是后话了。<br><img src="https://user-images.githubusercontent.com/20558748/36677027-245a2cee-1b48-11e8-9a96-1a8fb9f26e2b.png" alt="DatePicker"></p><p><strong>2017.4</strong><br>趁热打铁，分享了一波Android7.x新特性。因为原本在税友就分享过一次，这次分享得游刃有余，不仅介绍了新特性，同时还提到了多处兼容问题，需要在编码过程中注意的。而且都是大多是亲身经历，比较有说服力。</p><p><strong>2017.5</strong><br>年会。抽了个华米运动手表。用了半年左右，电池电量撑不了一天，废了。</p><p>正式接手聊天库。当时在做的需求是xxx(app名)的“xx交易2.0”。(比较讽刺的是，在后来的某个版本里，整个群聊交易系统都被砍了。)此时，聊天库至少经手了3个人的维护，我是第4个。未曾料想，我可能一不小心就成了这4个人里维护时间最长的维护者。</p><p>很膨胀，提了提前转正申请。也成功了。</p><p><strong>2017.6-8</strong><br>聊天库也不总是有需求，期间师父让我做了”图片加载包装库&amp;webp”和”网络接口流量统计”。</p><p>前者，一直找不到好的处理方式，尤其是fresco使用的不是ImageView而是Fresco特有的SimpleDraweeView。不知该如何处理各个图片加载引擎的切换。我简单地理解成，包装好后不用关心当前使用的是什么图片加载框架，用相同的代码就可以实现图片加载。似乎并不是这么简单，但我想不到，我第一次感受到我的知识储备限制了我的能力施展空间。</p><p>后者，也做了几个月。让我较为深入地了解了http协议。学会了抓包和计算报文大小。本来测试都通过了。最终因为数据库相关的操作，被打了回来。后来说是修复好后，等下个版本再上。</p><p><strong>2017.9</strong><br>内推了女朋友。通过了笔试，技术面，hr面。在最后hr将要给offer的时候。<br>“你和内推人是什么关系？” “他是我男朋友。”<br>因为一句话毁了所有努力。</p><p>工作上不顺利，对公司制度也充满了失望。</p><p><strong>2017.10</strong><br>又是一波聊天、消息相关的需求。匿名xxx需求、进群xx通知、xx上拍播报、动态卡片定义、消息重新归类。这些没什么挑战性，也算是拾回了一些信心，却开始被一些外界因素所影响。杨总做iOS端开发，基本上跟我接的都是一致的需求。但他对工作的懒散态度，让我很不习惯。师父也教导我不要学他(杨总)，他(杨总)是要走(离职)的人。</p><p><strong>2017.11-12</strong><br>业务组那边有每周一次的代码review会议，每次都会叫上一名架构组大佬。这一次轮到了我，本来想好好参与其中，粗心的自己却犯了好几处错误，真是给我们架构组丢人。<br><img src="https://user-images.githubusercontent.com/20558748/36677727-e54bd0d2-1b49-11e8-8346-3056793bcfa4.png" alt="丢人"></p><p>易诚拍相关的业务，大佬们忙不过来了，扔了一小部分给我(和杨总)。分别是“xxx扫描”和“消息库接入xxx(app名字)”。有时候真的不是很好界定任务的归属，消息库确实没话可说，跟聊天库一起都归属于消息中心，所以消息库也归我维护，自然归我接入。但是行驶证扫描本就是业务组同学写的库，现在需要接入易诚拍，需要我在他的库基础上修改，这种改动有些不合常理。</p><p>又接到一个比较富有挑战性的自定义View的任务，日历任务管理(仿钉钉日历)。本来完成得挺好的，但是…说来话长。iOS端原本是杨总实现，但他找了第三方的日历控件，实现后无法满足业务场景，又因为要离职的事情。所以任务直接压到了成哥那边，成哥本来就有其他任务在身，也来不及自己实现，只好又找了一个第三方的日历控件(但比杨总找的好)，又自己实现了和RN的事件回调。而我对自己的能力还是很有信心的，所以一切从头撸。不过我的实现与他截然不同，导致了两端实现的控件在RN中使用时不统一，这我就很烦。我承认我的实现不够人性化，甚至有点Android布局的思想在里面。(正确的做法应该倾向于‘提供给RN使用’的角度去设计控件)。但是，我做的日历组件性能好啊~滑动开合毫无阻塞。也说不好两端不统一的情况下应该让哪一端改。不过我确实很不想改，毕竟辛辛苦苦实现了这么久，iOS端只是copy+paste。后来师父跟我谈心，提及此事，略加批评。我也认为做法不妥。改不改都该给个回音，不应该在上级要求改之后，并不改动也不向上级请示能否不改。凡事都可商量，凡事都该有个回响。<br><img src="https://user-images.githubusercontent.com/20558748/36678150-f8175708-1b4a-11e8-8acd-b9438b03a77b.png" alt="日历"></p><p><strong>2018.1-2018.2</strong><br>复活xxx聊天xxx·一期<br>又是消息中心的一个大需求。背景是大风车的微信机器人屡次被微信封杀，现在需要将机器人业务迁移到xxx(app名称)上。但是之前的聊天相关的业务都不成功。聊天中也存在很多bug。故一期主要是为了优化原来的聊天库。</p><p>前期开发很顺利。后期由于杨总的盲目乐观和不根据设计稿、需求文档开发，导致大家等他一个人修bug、打包。我也算尽心尽力提醒他了相关的注意点，但他似乎心不在焉。我无话可说，只是希望以后给我派个靠谱的搭档。</p><p>后来发现我想多了，因为杨总的离开和聊天库的业务化，聊天库将交给业务组打理。有点舍不得，毕竟维护了这么久。算了算了，先做完复活xxx聊天xxx·二期吧。一切向前看。</p><p><strong>最后说几句</strong><br>刚入职时，大搜车才B轮，结果在春节前已经完成了C、D、E轮融资，这融资速度有点惊人。但是对员工的福利的一点儿也没涨。年前发的年货还不如我在税友当实习生时拿的多；年后的开门红包也缩水严重(据同事透露，往年是今年的3倍)；还有亲属不得内推的规定也是让人恼火，一点也没有阿里系的大气作风。</p><p>2017一年工作上对自己的打击其实挺大的。一度认为自己待在大搜车没什么价值，不是没东西学，而且做了东西没什么用。</p><p>2018年，希望可以多完成一些有挑战性的任务吧。把失去的找回来！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么2017还是看2018&quot;&gt;&lt;a href=&quot;#什么2017还是看2018&quot; class=&quot;headerlink&quot; title=&quot;什么2017还是看2018&quot;&gt;&lt;/a&gt;什么2017还是看2018&lt;/h1&gt;&lt;p&gt;去年年末看到好多小伙伴在写年终总结，有关生活的，有关工作的，对来年(2018)的展望的，没有丝毫的想法，不知怎的没有动笔的冲动。直到今天(开年第一天上班)，头哥给大伙开了个会，讲了很多关于工作上的规划和以及每个人在团队里的定位，内容很多，并不能完全消化，但确实给了我很大的启发，让我动了写这篇总结的念头。&lt;/p&gt;
&lt;p&gt;其实我一直是个有规划的人，大学四年的所有资料、文档、代码，我都会挨个儿根据科目、学期分文件夹。这一次，也要细细来讲，但并不想确保条理清晰。&lt;/p&gt;
&lt;p&gt;虽然说是2017-2018，其实应该是2017的春节-2018的春节。那么，开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="https://relish.wang/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://relish.wang/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>仿Photoshop取色器ColorPicker(四)</title>
    <link href="https://relish.wang/posts/28209/"/>
    <id>https://relish.wang/posts/28209/</id>
    <published>2017-08-24T02:14:38.000Z</published>
    <updated>2019-06-15T18:43:38.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ColorPicker"><a href="#ColorPicker" class="headerlink" title="ColorPicker"></a>ColorPicker</h1><p>一款基于HSV颜色空间的仿Photoshop取色器的Android版颜色拾取器。</p><p>github地址：<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">https://github.com/relish-wang/ColorPicker</a></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇已经简单介绍了<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a>的核心自定义控件<a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/ColorPickerView.java" target="_blank" rel="noopener">ColorPickerView</a>的监听事件相关代码。接下来我们详细解析一下<a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/ColorPickerDialog.java" target="_blank" rel="noopener">ColorPickerDialog</a>的相关代码</p><p><strong>注：</strong></p><ul><li>1 如果你对HSV颜色空间和RGB颜色空间不够熟悉的话，请参看该系列的第一篇文章——<a href="http://relish.wang/2017/08/14/%E4%BB%BFPhotoshop%E5%8F%96%E8%89%B2%E5%99%A8ColorPicker-%E4%B8%80/">仿Photoshop取色器ColorPicker(一)</a></li><li>2 如果你对ColorPickerView的绘制流程不够熟悉的话 ，请参看该系列的第二篇文章<a href="http://relish.wang/2017/08/17/%E4%BB%BFPhotoshop%E5%8F%96%E8%89%B2%E5%99%A8ColorPicker-%E4%BA%8C/">仿Photoshop取色器ColorPicker(二)</a></li><li>3 如果你对ColorPickerView的颜色改变监听不够熟悉的话，请参看该系列第三篇文章<a href="http://relish.wang/2017/08/19/%E4%BB%BFPhotoshop%E5%8F%96%E8%89%B2%E5%99%A8ColorPicker-%E4%B8%89/">仿Photoshop取色器ColorPicker(三)</a></li></ul><p><img src="http://img.blog.csdn.net/20170824091959104?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Dialog示意图"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这是<code>ColorPickerDialog</code>唯一的构造方法，里面的主要内容都在<code>setUp()</code>方法里。</p><p>稍微梳理一下代码：</p><ul><li>1 文字输入监听：为显示当前选择的颜色的16进制码的EditText设置文字输入监听器</li><li>2 颜色改变监听：为ColorPickerView设置颜色改变监听</li><li>3 设置初始颜色：为ColorPickerDialog和ColorPickerView设置初始颜色</li><li>4 取消/完成颜色拾取：为取消/确认按钮设置监听</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private ColorPickerDialog(Context context, int initialColor) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">    setUp(initialColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setUp(int color) &#123;</span><br><span class="line">   // ...</span><br><span class="line">   // 省略丑陋的findViewById们</span><br><span class="line">   // ...</span><br><span class="line"></span><br><span class="line">    mEtHex.setOnEditorActionListener(this);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">// 省略丑陋的findViewById们</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">    mColorPicker.setOnColorChangedListener(this);</span><br><span class="line">    mOldColor.setBackgroundColor(color); // 颜色预览色板上显示旧颜色</span><br><span class="line">    mColorPicker.setColor(color, true); // 为ColorPickerView设置初始颜色</span><br><span class="line"></span><br><span class="line">    mBtnCancel.setOnClickListener(this); // 取消</span><br><span class="line">    mBtnConfirm.setOnClickListener(this); // 确认选择颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字输入监听"><a href="#文字输入监听" class="headerlink" title="文字输入监听"></a>文字输入监听</h3><p>当点击软键盘上的【完成】按钮时触发监听</p><ul><li>1 当输入内容的长度<strong>在0到7之间</strong>(不包含边界)触发<strong>颜色变化</strong><ul><li>当颜色转化发生<strong>异常</strong>时，将内容显示成<strong>红色</strong>以<strong>提醒</strong>用户<strong>输入错误</strong>，且<strong>不</strong>进行<strong>颜色变化</strong></li></ul></li><li>2 当输入内容的长度<strong>不在这个区间</strong>，则将内容显示成<strong>红色</strong>以<strong>提醒</strong>用户<strong>输入错误</strong>，且<strong>不</strong>进行<strong>颜色变化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123;</span><br><span class="line">    if (actionId == EditorInfo.IME_ACTION_DONE) &#123;</span><br><span class="line">        InputMethodManager imm = (InputMethodManager) v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class="line">        imm.hideSoftInputFromWindow(v.getWindowToken(), 0);</span><br><span class="line">        String hexVal = mEtHex.getText().toString();</span><br><span class="line">        if (hexVal.length() &gt; 0 || hexVal.length() &lt; 7) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int c = Utils.convertToColorInt(hexVal);</span><br><span class="line">                mColorPicker.setColor(c, true);</span><br><span class="line">                mEtHex.setTextColor(mHexDefaultTextColor);</span><br><span class="line">            &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                mEtHex.setTextColor(Color.RED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mEtHex.setTextColor(Color.RED);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="颜色转化"><a href="#颜色转化" class="headerlink" title="颜色转化"></a>颜色转化</h4><p>排除异常情况，正常情况下执行功能的主要是一下三行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int c = Utils.convertToColorInt(hexVal);</span><br><span class="line">mColorPicker.setColor(c, true);</span><br><span class="line">mEtHex.setTextColor(mHexDefaultTextColor);</span><br></pre></td></tr></table></figure><p>让我们查看一下<code>Utils.convertToColorInt()</code>的实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ARGB(含RGB)颜色 转 16进制颜色</span><br><span class="line"> *</span><br><span class="line"> * @param argb ARGB(含RGB)颜色</span><br><span class="line"> * @return 16进制颜色</span><br><span class="line"> * @throws NumberFormatException 当&#123;@param argb&#125;不是一个正确的颜色格式的字符串时</span><br><span class="line"> */</span><br><span class="line">static int convertToColorInt(@NonNull String argb) throws IllegalArgumentException &#123;</span><br><span class="line">    if (argb.matches(&quot;[0-9a-fA-F]&#123;1,6&#125;&quot;)) &#123;</span><br><span class="line">        switch (argb.length()) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                return Color.parseColor(&quot;#00000&quot; + argb);</span><br><span class="line">            case 2:</span><br><span class="line">                return Color.parseColor(&quot;#0000&quot; + argb);</span><br><span class="line">            case 3:</span><br><span class="line">                char r = argb.charAt(0), g = argb.charAt(1), b = argb.charAt(2);</span><br><span class="line">                //noinspection StringBufferReplaceableByString</span><br><span class="line">                return Color.parseColor(new StringBuilder(&quot;#&quot;)</span><br><span class="line">                        .append(r).append(r)</span><br><span class="line">                        .append(g).append(g)</span><br><span class="line">                        .append(b).append(b)</span><br><span class="line">                        .toString());</span><br><span class="line">            case 4:</span><br><span class="line">                return Color.parseColor(&quot;#00&quot; + argb);</span><br><span class="line">            case 5:</span><br><span class="line">                return Color.parseColor(&quot;#0&quot; + argb);</span><br><span class="line">            case 6:</span><br><span class="line">                return Color.parseColor(&quot;#&quot; + argb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(argb + &quot; is not a valid color.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑我主要参考了Photoshop里颜色选择器对手动输入颜色进行的操作。</p><ul><li>1位: #00000x</li><li>2位: #0000xx</li><li>3位: #aabbcc</li><li>4位: #00xxxx</li><li>5位: #0xxxxx</li><li>6位: #xxxxxx</li></ul><p>略微观察可以发现，除了3位的时候要特殊处理，其他的情况下都是在前面加足够数量的0，以凑齐6位颜色编码。</p><p><strong>关于异常处理Tips</strong>：在这里，只要是不符合正则表达式的颜色字符串，都会直接向外抛出异常，而不是进行捕捉。回到前一段关于颜色监听的代码可以发现，在监听中我们捕获了异常，并用输入框颜色的改变以反馈用户。因此对于异常的<strong>捕捉</strong>与<strong>抛</strong>也是有讲究的。</p><h3 id="颜色改变监听"><a href="#颜色改变监听" class="headerlink" title="颜色改变监听"></a>颜色改变监听</h3><p>这里的逻辑就比较显而易见了</p><ul><li>用于显示当前选择的颜色的色块更新颜色</li><li>如果启用了颜色编码显示，则更新输入框中的颜色</li></ul><p><strong>注</strong>：这里可能会有疑问。我在输入框中<strong>手动输入</strong>了颜色编码，从而<code>ColorPickerView</code>更新了颜色，触发了<code>onColorChanged()</code>，反过来<strong>又更新</strong>输入框里的颜色编码。这这这…这难道不就循环了吗？这也是我之前考虑到的一个问题，因此并没有给显示颜色编码的输入框设置<code>TextWatcher</code>，而是<code>OnEditorActionListener</code>，且只有在用户输入完成点输入法右下角的[完成/Done]按钮才会触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onColorChanged(int color) &#123;</span><br><span class="line">    mNewColor.setBackgroundColor(color);</span><br><span class="line">    if (mHexValueEnabled) updateHexValue(color);</span><br><span class="line">&#125;</span><br><span class="line">private void updateHexValue(int color) &#123;</span><br><span class="line">    mEtHex.setText(Utils.convertToRGB(color).toUpperCase(Locale.getDefault()));</span><br><span class="line">    mEtHex.setTextColor(mHexDefaultTextColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建Dialog实例"><a href="#创建Dialog实例" class="headerlink" title="创建Dialog实例"></a>创建Dialog实例</h2><p>ColorPickerDialog的代码量并没有ColorPickerView那么多，其实讲完初始化就已经讲完了它的核心功能的代码了，接下来直接讲解使用。</p><p>回到本文最初介绍ColorPicker初始化的地方，可以看到ColorPickerDialog的唯一的一个构造方法是<code>private</code>的，因为我把它做成了Builder模式，这样使用起来更灵活。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new ColorPickerDialog.Builder(MainActivity.this, mColor)//上下文, 初始化颜色</span><br><span class="line">    .setHexValueEnabled(mHexValueEnable)//是否显示颜色值(boolean)</span><br><span class="line">    .setOnColorPickedListener(mListener)//设置颜色拾取监听器</span><br><span class="line">    .build()</span><br><span class="line">    .show();//展示</span><br></pre></td></tr></table></figure><p>颜色拾取监听器OnColorPickedListener:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onColorPicked(int color) &#123;</span><br><span class="line">    mColor = color;</span><br><span class="line">    mViewColor.setBackgroundColor(mColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>好了,经过四篇文章的学习，我们已经将ColorPicker中最核心的代码学习完了，相信你从头看到这里对Android自定义View的理解又更深了一层，甚至学到了颜色相关的一些其他知识，比如HSV颜色空间、HSV与RGB颜色转化。</p><p>最后，欢迎大家给我提供宝贵的意见和建议，进一步优化ColorPicker。<br>GitHub地址: <a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">https://github.com/relish-wang/ColorPicker</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ColorPicker&quot;&gt;&lt;a href=&quot;#ColorPicker&quot; class=&quot;headerlink&quot; title=&quot;ColorPicker&quot;&gt;&lt;/a&gt;ColorPicker&lt;/h1&gt;&lt;p&gt;一款基于HSV颜色空间的仿Photoshop取色器的Android版颜色拾取器。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/relish-wang/ColorPicker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/relish-wang/ColorPicker&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android自定义View" scheme="https://relish.wang/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="自定义View" scheme="https://relish.wang/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="color" scheme="https://relish.wang/tags/color/"/>
    
      <category term="photoshop" scheme="https://relish.wang/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>仿Photoshop取色器ColorPicker(三)</title>
    <link href="https://relish.wang/posts/63693/"/>
    <id>https://relish.wang/posts/63693/</id>
    <published>2017-08-19T03:44:33.000Z</published>
    <updated>2019-06-15T18:43:38.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ColorPicker"><a href="#ColorPicker" class="headerlink" title="ColorPicker"></a>ColorPicker</h1><p>一款基于HSV颜色空间的仿Photoshop取色器的Android版颜色拾取器。</p><p>github地址：<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇已经简单介绍了<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a>的核心自定义控件<a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/ColorPickerView.java" target="_blank" rel="noopener">ColorPickerView</a>的绘制流程。接下来我们详细解析一下<a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/ColorPickerView.java" target="_blank" rel="noopener">ColorPickerView</a>的监听事件相关代码。</p><p><strong>注：</strong></p><ul><li>1 如果你对HSV颜色空间和RGB颜色空间不够熟悉的话，请参看该系列的第一篇文章——<a href="http://relish.wang/2017/08/14/%E4%BB%BFPhotoshop%E5%8F%96%E8%89%B2%E5%99%A8ColorPicker-%E4%B8%80/">仿Photoshop取色器ColorPicker(一)</a></li><li>2 如果你对ColorPickerView的绘制流程不熟悉的话 ，请参看该系列的第二篇文章<a href="http://relish.wang/2017/08/17/%E4%BB%BFPhotoshop%E5%8F%96%E8%89%B2%E5%99%A8ColorPicker-%E4%BA%8C/">仿Photoshop取色器ColorPicker(二)</a></li></ul><h2 id="初始颜色传入"><a href="#初始颜色传入" class="headerlink" title="初始颜色传入"></a>初始颜色传入</h2><p>在讲颜色改变监听之前，先来讲讲初始颜色传入时，代码的变化吧!</p><ul><li>1 先把RGB颜色转化成HSV三个值</li><li>2 刷新页面<code>invalidate</code></li></ul><p><strong>说明</strong>：调用<code>invalidate</code>后，View会触发<code>onDraw()</code>方法，因此两个调色板会根据现在的HSV值绘制当前显示的色板以及指示器的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void setColor(int color) &#123;</span><br><span class="line">    setColor(color, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setColor(int color, boolean callback) &#123;</span><br><span class="line">    float[] hsv = new float[3];</span><br><span class="line">    Color.colorToHSV(color, hsv);</span><br><span class="line">    mHue = hsv[0];</span><br><span class="line">    mSat = hsv[1];</span><br><span class="line">    mVal = hsv[2];</span><br><span class="line">    if (callback &amp;&amp; mListener != null) &#123;</span><br><span class="line">        mListener.onColorChanged(Color.HSVToColor(new float[]&#123;mHue, mSat, mVal&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="颜色改变监听事件"><a href="#颜色改变监听事件" class="headerlink" title="颜色改变监听事件"></a>颜色改变监听事件</h2><p>在选择颜色过程中，会触发两种监听事件：轨迹球拖拽事件(<code>onTrackballEvent</code>)、屏幕点击事件(<code>onTouchEvent</code>)</p><h3 id="轨迹球拖拽事件onTrackballEvent"><a href="#轨迹球拖拽事件onTrackballEvent" class="headerlink" title="轨迹球拖拽事件onTrackballEvent"></a>轨迹球拖拽事件onTrackballEvent</h3><p>观察这边的代码，这里分为两种情况处理：</p><ul><li>当前触点在[饱和度灰度调色板]上<ul><li>根据x、y坐标获得sat(饱和度)、val(灰度)值（并且做了边界处理）</li></ul></li><li>当前触点在[色相调色板]上<ul><li>根据y轴坐标获得hue(色相)值 (并且做了边界处理)</li></ul></li></ul><p>最后再将HSV值换算成RGB值，通过监听器回调给上一级(ColorPickerDialog)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTrackballEvent(MotionEvent event) &#123;</span><br><span class="line">    float x = event.getX();</span><br><span class="line">    float y = event.getY();</span><br><span class="line">    boolean isUpdated = false;</span><br><span class="line">    if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">        switch (mLastTouchedPanel) &#123;</span><br><span class="line">            case PANEL.SAT_VAL:</span><br><span class="line">                float sat, val;</span><br><span class="line">                sat = mSat + x / 50f;</span><br><span class="line">                val = mVal - y / 50f;</span><br><span class="line">                if (sat &lt; 0f) &#123;</span><br><span class="line">                    sat = 0f;</span><br><span class="line">                &#125; else if (sat &gt; 1f) &#123;</span><br><span class="line">                    sat = 1f;</span><br><span class="line">                &#125;</span><br><span class="line">                if (val &lt; 0f) &#123;</span><br><span class="line">                    val = 0f;</span><br><span class="line">                &#125; else if (val &gt; 1f) &#123;</span><br><span class="line">                    val = 1f;</span><br><span class="line">                &#125;</span><br><span class="line">                mSat = sat;</span><br><span class="line">                mVal = val;</span><br><span class="line">                isUpdated = true;</span><br><span class="line">                break;</span><br><span class="line">            case PANEL.HUE:</span><br><span class="line">                float hue = mHue - y * 10f;</span><br><span class="line">                if (hue &lt; 0f) &#123;</span><br><span class="line">                    hue = 0f;</span><br><span class="line">                &#125; else if (hue &gt; 360f) &#123;</span><br><span class="line">                    hue = 360f;</span><br><span class="line">                &#125;</span><br><span class="line">                mHue = hue;</span><br><span class="line">                isUpdated = true;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (isUpdated) &#123;</span><br><span class="line">        if (mListener != null) &#123;</span><br><span class="line">            mListener.onColorChanged(Color.HSVToColor(new float[]&#123;mHue, mSat, mVal&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onTrackballEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="屏幕点击事件onTrackballEvent"><a href="#屏幕点击事件onTrackballEvent" class="headerlink" title="屏幕点击事件onTrackballEvent"></a>屏幕点击事件onTrackballEvent</h3><ul><li>1 监听了手指的DOWN、UP、MOVE的事件</li><li>2 具体处理逻辑在<code>moveTrackersIfNeeded()</code>方法中<ul><li>2.1 先判断触点是否在调色板内</li><li>2.2 然后根据调色板更新对应的sat、val值或hue值</li></ul></li><li>3 根据是否更新了颜色进行监听回调</li><li>4 刷新页面<code>invalidate();</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    boolean isUpdated = false;</span><br><span class="line">    switch (event.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            mStartTouchPoint = new Point((int) event.getX(), (int) event.getY());</span><br><span class="line">            isUpdated = moveTrackersIfNeeded(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            isUpdated = moveTrackersIfNeeded(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            mStartTouchPoint = null;</span><br><span class="line">            isUpdated = moveTrackersIfNeeded(event);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (isUpdated) &#123;</span><br><span class="line">        if (mListener != null) &#123;</span><br><span class="line">            mListener.onColorChanged(Color.HSVToColor(new float[]&#123;mHue, mSat, mVal&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean moveTrackersIfNeeded(MotionEvent event) &#123;</span><br><span class="line">    if (mStartTouchPoint == null) return false;</span><br><span class="line">    boolean update = false;</span><br><span class="line">    int startX = mStartTouchPoint.x;</span><br><span class="line">    int startY = mStartTouchPoint.y;</span><br><span class="line">    if (mHueRect.contains(startX, startY)) &#123;</span><br><span class="line">        mLastTouchedPanel = PANEL.HUE;</span><br><span class="line">        mHue = pointToHue(event.getY());</span><br><span class="line">        update = true;</span><br><span class="line">    &#125; else if (mSatValRect.contains(startX, startY)) &#123;</span><br><span class="line">        mLastTouchedPanel = PANEL.SAT_VAL;</span><br><span class="line">        float[] result = pointToSatVal(event.getX(), event.getY());</span><br><span class="line">        mSat = result[0];</span><br><span class="line">        mVal = result[1];</span><br><span class="line">        update = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后汇总一下，今天这篇文章主要讲了，ColorPickerView的初始颜色传入+颜色改变监听。下一篇将讲解ColorPickerDialog的主要代码，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ColorPicker&quot;&gt;&lt;a href=&quot;#ColorPicker&quot; class=&quot;headerlink&quot; title=&quot;ColorPicker&quot;&gt;&lt;/a&gt;ColorPicker&lt;/h1&gt;&lt;p&gt;一款基于HSV颜色空间的仿Photoshop取色器的Android版颜色拾取器。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/relish-wang/ColorPicker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ColorPicker&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android自定义View" scheme="https://relish.wang/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="自定义View" scheme="https://relish.wang/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="color" scheme="https://relish.wang/tags/color/"/>
    
      <category term="photoshop" scheme="https://relish.wang/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>仿Photoshop取色器ColorPicker(二)</title>
    <link href="https://relish.wang/posts/26735/"/>
    <id>https://relish.wang/posts/26735/</id>
    <published>2017-08-17T14:30:31.000Z</published>
    <updated>2019-06-15T18:43:38.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ColorPicker"><a href="#ColorPicker" class="headerlink" title="ColorPicker"></a>ColorPicker</h1><p>一款基于HSV颜色空间的仿Photoshop取色器的Android版颜色拾取器。</p><p>github地址：<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇已经简单介绍了<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a>的项目结构以及两种颜色空间，接下来我们详细解析一下<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a>的核心自定义控件<a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/ColorPickerView.java" target="_blank" rel="noopener">ColorPickerView</a>。</p><h2 id="ColorPickerView"><a href="#ColorPickerView" class="headerlink" title="ColorPickerView"></a>ColorPickerView</h2><p>在阅读代码之前，我们先看一下ColorPicker的布局以及一些标注的数值在代码里的变量名称。<br><img src="http://img.blog.csdn.net/20170817215505998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="介绍"></p><p><img src="http://img.blog.csdn.net/20170817215957719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="变量名"></p><p><a href="http://img.blog.csdn.net/20170817215851246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener">变量名标注的的大图</a></p><p>阅读一个自定义View的代码，只需记住四步走：<code>构造方法</code>、<code>onMeasure</code>、<code>onLayout</code>、<code>onDraw</code></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ColorPickerView(Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ColorPickerView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ColorPickerView(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">    super(context, attrs, defStyle);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，前2个构造器最后都调用了第三个构造器。而第三个构造器里的主要内容都在一个名为<code>init()</code>的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">    mDensity = getContext().getResources().getDisplayMetrics().density;//获取屏幕密度</span><br><span class="line">    mSVTrackerRadius *= mDensity;//灰度饱和度指示器的半径</span><br><span class="line">    mRectOffset *= mDensity;//H、SV矩形与父布局的边距</span><br><span class="line">    mHuePanelWidth *= mDensity;//H矩形的宽度</span><br><span class="line">    mPanelSpacing *= mDensity;//H、SV矩形间的间距</span><br><span class="line">    mPreferredHeight *= mDensity;//当mode为MeasureSpec.UNSPECIFIED时的首选高度</span><br><span class="line">    mPreferredWidth *= mDensity;//当mode为MeasureSpec.UNSPECIFIED时的首选宽度</span><br><span class="line"></span><br><span class="line">    mDrawingOffset = calculateRequiredOffset();//计算所需位移</span><br><span class="line"></span><br><span class="line">    initPaintTools();//初始化画笔、画布</span><br><span class="line"></span><br><span class="line">    setFocusable(true);//设置可获取焦点</span><br><span class="line">    setFocusableInTouchMode(true);//设置在被触摸时会获取焦点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init</code>方法里有很多变量，它们的含义如下图所示：<br><img src="http://img.blog.csdn.net/20170817203201694?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="变量名"></p><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    int widthAllowed = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    int heightAllowed = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    widthAllowed = isUnspecified(widthMode) ? (int) mPreferredWidth : widthAllowed;</span><br><span class="line">    heightAllowed = isUnspecified(heightMode) ? (int) mPreferredHeight : heightAllowed;</span><br><span class="line"></span><br><span class="line">    int width = widthAllowed;</span><br><span class="line">    int height = (int) (widthAllowed - mPanelSpacing - mHuePanelWidth);</span><br><span class="line">    //当根据宽度计算出来的高度大于可允许的最大高度时 或 当前是横屏</span><br><span class="line">    if (height &gt; heightAllowed || &quot;landscape&quot;.equals(getTag())) &#123;</span><br><span class="line">        height = heightAllowed;</span><br><span class="line">        width = (int) (height + mPanelSpacing + mHuePanelWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isUnspecified(int mode) &#123;</span><br><span class="line">    return !(mode == MeasureSpec.EXACTLY || mode == MeasureSpec.AT_MOST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测量模式(<code>MeasureSpecMode</code>)分为<code>EXACTLY</code>、<code>AT_MOST</code>、<code>UNSPECIFIED</code>三种类型。前两种类型可以通过<code>MeasureSpec.getSize(int measureSpec)</code>获得具体的值；当测量模式为<code>UNSPECIFIED</code>时，需要我们自己确定自定义View的高宽。这里我设定了一些默认值，使ColorPicker看起来更舒服。</p><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p>这里使用了父类的onLayout方法。</p><h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><p>绘制<code>ColorPickerView</code>分为两个部分：饱和度灰度调色板<code>mSatValRect</code>+色相调色板<code>mHueRect</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    if (mDrawingRect.width() &lt;= 0 || mDrawingRect.height() &lt;= 0) return;</span><br><span class="line">    drawSatValPanel(canvas);//绘制SV选择区域</span><br><span class="line">    drawHuePanel(canvas);//绘制右侧H选择区域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始了解具体绘制细节之前，希望读者已经了解过<code>Shader</code>(着色器)的相关知识。</p><h4 id="绘制饱和度灰度调色板"><a href="#绘制饱和度灰度调色板" class="headerlink" title="绘制饱和度灰度调色板"></a>绘制饱和度灰度调色板</h4><p>1 先画一个大矩形，再在上面画我们的饱和度灰度调色板，这样看起来有一个描边的效果。<br>2 绘制饱和度灰度指示器。根据当前选择的颜色定位到具体的坐标，在这个坐标上做画。先画一个半径为<code>mSVTrackerRadius</code>、边线粗细为<code>mDensity</code>的空心大圆，再在上面画一个半径为<code>mSVTrackerRadius-mDensity</code>、边线粗细为<code>mDensity</code>的空心小圆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 绘制S、V选择区域（矩形）</span><br><span class="line"> *</span><br><span class="line"> * @param canvas 画布</span><br><span class="line"> */</span><br><span class="line">private void drawSatValPanel(Canvas canvas) &#123;</span><br><span class="line">    //描边（先画一个大矩形, 再在内部画一个小矩形，就可以显示出描边的效果）</span><br><span class="line">    mBorderPaint.setColor(mBorderColor);</span><br><span class="line">    canvas.drawRect(</span><br><span class="line">            mDrawingRect.left,</span><br><span class="line">            mDrawingRect.top,</span><br><span class="line">            mSatValRect.right + BORDER_WIDTH,</span><br><span class="line">            mSatValRect.bottom + BORDER_WIDTH,</span><br><span class="line">            mBorderPaint);</span><br><span class="line"></span><br><span class="line">    //组合着色器 = 明度线性着色器 + 饱和度线性着色器</span><br><span class="line">    ComposeShader mShader = generateSVShader();</span><br><span class="line">    mSatValPaint.setShader(mShader);</span><br><span class="line">    canvas.drawRect(mSatValRect, mSatValPaint);</span><br><span class="line"></span><br><span class="line">    //初始化选择器的位置</span><br><span class="line">    Point p = satValToPoint(mSat, mVal);</span><br><span class="line">    //绘制显示SV值的选择器</span><br><span class="line">    mSatValTrackerPaint.setColor(0xff000000);</span><br><span class="line">    canvas.drawCircle(p.x, p.y, mSVTrackerRadius - 1f * mDensity, mSatValTrackerPaint);</span><br><span class="line">    //绘制外圆</span><br><span class="line">    mSatValTrackerPaint.setColor(0xffdddddd);</span><br><span class="line">    canvas.drawCircle(p.x, p.y, mSVTrackerRadius, mSatValTrackerPaint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建SV着色器(明度线性着色器 + 饱和度线性着色器)</span><br><span class="line"> *</span><br><span class="line"> * @return 着色器</span><br><span class="line"> */</span><br><span class="line">private ComposeShader generateSVShader() &#123;</span><br><span class="line">    //明度线性着色器</span><br><span class="line">    if (mValShader == null) &#123;</span><br><span class="line">        mValShader = new LinearGradient(mSatValRect.left, mSatValRect.top, mSatValRect.left, mSatValRect.bottom,</span><br><span class="line">                0xffffffff, 0xff000000, TileMode.CLAMP);</span><br><span class="line">    &#125;</span><br><span class="line">    //HSV转化为RGB</span><br><span class="line">    int rgb = Color.HSVToColor(new float[]&#123;mHue, 1f, 1f&#125;);</span><br><span class="line">    //饱和线性着色器</span><br><span class="line">    Shader satShader = new LinearGradient(mSatValRect.left, mSatValRect.top, mSatValRect.right, mSatValRect.top,</span><br><span class="line">            0xffffffff, rgb, TileMode.CLAMP);</span><br><span class="line">    //组合着色器 = 明度线性着色器 + 饱和度线性着色器</span><br><span class="line">    return new ComposeShader(mValShader, satShader, PorterDuff.Mode.MULTIPLY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制色相调色板"><a href="#绘制色相调色板" class="headerlink" title="绘制色相调色板"></a>绘制色相调色板</h4><p>1 同理绘制矩形调色板<br>2 同理绘制空心圆角矩形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 绘制右侧H选择区域</span><br><span class="line"> *</span><br><span class="line"> * @param canvas 画布</span><br><span class="line"> */</span><br><span class="line">private void drawHuePanel(Canvas canvas) &#123;</span><br><span class="line">    final RectF rect = mHueRect;</span><br><span class="line"></span><br><span class="line">    mBorderPaint.setColor(mBorderColor);</span><br><span class="line">    canvas.drawRect(rect.left - BORDER_WIDTH,</span><br><span class="line">            rect.top - BORDER_WIDTH,</span><br><span class="line">            rect.right + BORDER_WIDTH,</span><br><span class="line">            rect.bottom + BORDER_WIDTH,</span><br><span class="line">            mBorderPaint);</span><br><span class="line">    //初始化H线性着色器</span><br><span class="line">    if (mHueShader == null) &#123;</span><br><span class="line">        int[] hue = new int[361];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = hue.length - 1; i &gt;= 0; i--, count++) &#123;</span><br><span class="line">            hue[count] = Color.HSVToColor(new float[]&#123;i, 1f, 1f&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        mHueShader = new LinearGradient(</span><br><span class="line">                rect.left,</span><br><span class="line">                rect.top,</span><br><span class="line">                rect.left,</span><br><span class="line">                rect.bottom,</span><br><span class="line">                hue,</span><br><span class="line">                null,</span><br><span class="line">                TileMode.CLAMP);</span><br><span class="line">        mHuePaint.setShader(mHueShader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.drawRect(rect, mHuePaint);</span><br><span class="line"></span><br><span class="line">     float halfHTrackerHeight= mHTrackerHeight / 2;</span><br><span class="line">    //初始化H选择器选择条位置</span><br><span class="line">    Point p = hueToPoint(mHue);</span><br><span class="line"></span><br><span class="line">    RectF r = new RectF();</span><br><span class="line">    r.left = rect.left - mRectOffset;</span><br><span class="line">    r.right = rect.right + mRectOffset;</span><br><span class="line">    r.top = p.y - halfHTrackerHeight;</span><br><span class="line">    r.bottom = p.y + halfHTrackerHeight;</span><br><span class="line"></span><br><span class="line">    //绘制选择条</span><br><span class="line">    canvas.drawRoundRect(r, 2, 2, mHueTrackerPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，整个ColorPickerView的绘制流程就都在这里了。<br>下一篇主要讲解ColorPickerView初始颜色传入和颜色改变监听相关代码：<a href="http://relish.wang/2017/08/19/%E4%BB%BFPhotoshop%E5%8F%96%E8%89%B2%E5%99%A8ColorPicker-%E4%B8%89/">仿Photoshop取色器ColorPicker(三)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ColorPicker&quot;&gt;&lt;a href=&quot;#ColorPicker&quot; class=&quot;headerlink&quot; title=&quot;ColorPicker&quot;&gt;&lt;/a&gt;ColorPicker&lt;/h1&gt;&lt;p&gt;一款基于HSV颜色空间的仿Photoshop取色器的Android版颜色拾取器。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/relish-wang/ColorPicker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ColorPicker&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android自定义View" scheme="https://relish.wang/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="自定义View" scheme="https://relish.wang/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="color" scheme="https://relish.wang/tags/color/"/>
    
      <category term="photoshop" scheme="https://relish.wang/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>仿Photoshop取色器ColorPicker(一)</title>
    <link href="https://relish.wang/posts/43211/"/>
    <id>https://relish.wang/posts/43211/</id>
    <published>2017-08-14T07:40:33.000Z</published>
    <updated>2019-06-15T18:43:38.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ColorPicker"><a href="#ColorPicker" class="headerlink" title="ColorPicker"></a>ColorPicker</h1><p>一款仿Photoshop取色器的Android版取色器。采用HSV颜色空间，可手动选取想要的颜色，也可以手动输入具体颜色的16进制编码以获取颜色（如：0xFFFFFF表示白色）。</p><p>github地址：<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a></p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><a href="https://github.com/relish-wang/ColorPicker/blob/master/image/colorpicker.gif" target="_blank" rel="noopener">ColorPicker效果图</a></p><a id="more"></a><h2 id="总体预览"><a href="#总体预览" class="headerlink" title="总体预览"></a>总体预览</h2><p><a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a>项目结构如下图所示：</p><p><img src="http://img.blog.csdn.net/20170814135427029?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="项目结构预览"></p><p>核心自定义控件: <a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/ColorPickerView.java" target="_blank" rel="noopener">ColorPickerView.java</a></p><p>颜色拾取对话框: <a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/ColorPickerDialog.java" target="_blank" rel="noopener">ColorPickerDialog.java</a></p><p>颜色转换相关工具: <a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/Utils.java" target="_blank" rel="noopener">Utils.java</a></p><p>对话框布局文件: <a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/res/layout/dialog_color_picker.xml" target="_blank" rel="noopener">dialog_color_picker.xml(纵向布局)</a>+<a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/res/layout-land/dialog_color_picker.xml" target="_blank" rel="noopener">dialog_color_picker.xml(横向布局)</a></p><p>其他文件内容都为项目构建时的默认内容。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始了解<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker</a>的具体实现之前，需要首先了解一些颜色相关的概念。</p><ul><li><a href="https://baike.baidu.com/item/RGB%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">RGB颜色空间</a>以R(Red:红)、G(Green:绿)、B(Blue:蓝)三种基本色为基础，进行不同程度的叠加，产生丰富而广泛的颜色，所以俗称三基色模式，也是大家所熟知的一种颜色空间。它分为xyz三轴，分别表示绿蓝红（三者取值均在0~255之间，包含边界），因此只要获得绿、蓝、红三个值就可以获得一个确切的颜色，所有的颜色构成了如下图所示的立方体，其中(0, 0, 0)到(255, 255, 255)体对角线表示黑到白的灰度值。</li></ul><p><img src="http://img.blog.csdn.net/20170814141708196?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="RGB颜色空间"></p><ul><li><a href="https://baike.baidu.com/item/HSV/547122?fr=aladdin&fromid=12630604&fromtitle=HSV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">HSV颜色空间</a>是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）。该模型以一个倒圆锥体的形式呈现。H表示圆锥体的底面圆弧上的某个点与圆心连线的线与红色表示的点与圆心连线的线形成的夹角大小。故其取值范围为0~360°（左闭右开；红色为0°，绿色为120°,蓝色为240°）。V颜色明亮的程度，越大明度越高，取值范围为(0,1)，包含边界。S表示颜色接近光谱色的程度，数值越大越接近光谱色，取值范围为(0,1)，包含边界。因此获得H、S、V三者的值也可以获得一个具体的颜色。</li></ul><p><img src="http://img.blog.csdn.net/20170814141238911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="HSV颜色空间"></p><p>而<a href="https://github.com/relish-wang/ColorPicker" target="_blank" rel="noopener">ColorPicker库</a>的<a href="https://github.com/relish-wang/ColorPicker/blob/master/library/src/main/java/wang/relish/colorpicker/ColorPickerView.java" target="_blank" rel="noopener">核心自定义控件ColorPickerView</a>的颜色拾取功能就是基于<a href="https://baike.baidu.com/item/HSV/547122?fr=aladdin&fromid=12630604&fromtitle=HSV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">HSV颜色空间</a>的。而且HSV和RGB是可以进行转换。不过不必担心转换，因为android.graphics.Color.java提供了转换方法：</p><p><img src="http://img.blog.csdn.net/20170814153708234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="hsv2rgb"></p><p><img src="http://img.blog.csdn.net/20170814153731569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUjNsaXNo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="rgb2hsv"></p><p>下一篇主要讲解ColorPickerView的绘制流程：<a href="http://relish.wang/2017/08/17/%E4%BB%BFPhotoshop%E5%8F%96%E8%89%B2%E5%99%A8ColorPicker-%E4%BA%8C/">仿Photoshop取色器ColorPicker(二)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ColorPicker&quot;&gt;&lt;a href=&quot;#ColorPicker&quot; class=&quot;headerlink&quot; title=&quot;ColorPicker&quot;&gt;&lt;/a&gt;ColorPicker&lt;/h1&gt;&lt;p&gt;一款仿Photoshop取色器的Android版取色器。采用HSV颜色空间，可手动选取想要的颜色，也可以手动输入具体颜色的16进制编码以获取颜色（如：0xFFFFFF表示白色）。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/relish-wang/ColorPicker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ColorPicker&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/relish-wang/ColorPicker/blob/master/image/colorpicker.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ColorPicker效果图&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android自定义View" scheme="https://relish.wang/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="Android" scheme="https://relish.wang/tags/Android/"/>
    
      <category term="自定义View" scheme="https://relish.wang/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="color" scheme="https://relish.wang/tags/color/"/>
    
      <category term="photoshop" scheme="https://relish.wang/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>MVPActivity-Template</title>
    <link href="https://relish.wang/posts/16683/"/>
    <id>https://relish.wang/posts/16683/</id>
    <published>2016-09-07T10:42:35.000Z</published>
    <updated>2019-06-15T18:43:38.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MVPActivity-Template"><a href="#MVPActivity-Template" class="headerlink" title="MVPActivity-Template"></a>MVPActivity-Template</h1><p>项目地址：<a href="https://github.com/relish-wang/MVPActivity-Template" target="_blank" rel="noopener">https://github.com/relish-wang/MVPActivity-Template</a></p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a><strong>效果图</strong></h2><p><img src="http://img.blog.csdn.net/20160907160753596" alt="效果图"></p><a id="more"></a><h2 id="0-导读"><a href="#0-导读" class="headerlink" title="0 导读"></a><strong>0 导读</strong></h2><p>MVP模式耳熟能详。虽然它降低了程序的耦合度，利于团队协作以及后期维护，但是它增加了代码量和文件量。程序员不得不每次为一个界面建立至少6个文件（三个接口，三个实现类，分别对应M、V、P），以及接口与实现类的继承关系、MVP三者之间的关系。如图：<br><img src="http://img.blog.csdn.net/20160907154427840" alt="这里写图片描述"><br>Presenter持有View和Model的实例，View、Model持有Presenter的实例。View与Model通过Presenter进行信息交互。<br>本文讲解重点并不是MVP模式。而是介绍该项目的使用来减少因MVP模式带来的重复劳动。</p><h2 id="1-Android-Studio-Template入门介绍"><a href="#1-Android-Studio-Template入门介绍" class="headerlink" title="1 Android Studio Template入门介绍"></a><strong>1 Android Studio Template入门介绍</strong></h2><p>首先需要了解什么是Android Studio Template。<br>打开AndroidStudio安装目录下文件夹</p><blockquote><p>[AndroidStudio安装目录]\plugins\android\lib\templates\activities</p></blockquote><p>可以在这里看到很多模板（Templates）<br><img src="http://img.blog.csdn.net/20160907155727129" alt="这里写图片描述"><br>看见这些文件夹名是不是很熟悉？没错这些就是我们在新建项目或新建Activity看到的<br><img src="http://img.blog.csdn.net/20160907155815099" alt="这里写图片描述"><br>我们只需要将自己编写的模板（Template）放到该文件夹下，就可以使用自己的模板了。</p><p>Android Studio Template资料传送门：<br>鸿洋_大神的两篇博客:</p><ul><li><a href="http://blog.csdn.net/lmj623565791/article/details/51592043" target="_blank" rel="noopener">神奇的Android Studio Template</a></li><li><a href="http://blog.csdn.net/lmj623565791/article/details/51635533" target="_blank" rel="noopener">Android Studio自定义模板 写页面竟然可以如此轻松</a></li></ul><h2 id="2-使用说明"><a href="#2-使用说明" class="headerlink" title="2 使用说明"></a><strong>2 使用说明</strong></h2><p>下载<a href="https://github.com/relish-wang/MVPActivity-Template" target="_blank" rel="noopener">MVPActivity-Template</a>。将MVPActivity文件夹拷贝到</p><blockquote><p>[AndroidStudio安装目录]\plugins\android\lib\templates\activities</p></blockquote><p>该目录下，重启Android Studio即可使用。(New-&gt;Activity-&gt;MVPActivity)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MVPActivity-Template&quot;&gt;&lt;a href=&quot;#MVPActivity-Template&quot; class=&quot;headerlink&quot; title=&quot;MVPActivity-Template&quot;&gt;&lt;/a&gt;MVPActivity-Template&lt;/h1&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/relish-wang/MVPActivity-Template&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/relish-wang/MVPActivity-Template&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160907160753596&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android Studio" scheme="https://relish.wang/categories/Android-Studio/"/>
    
    
      <category term="Android Studio" scheme="https://relish.wang/tags/Android-Studio/"/>
    
      <category term="Template" scheme="https://relish.wang/tags/Template/"/>
    
      <category term="插件" scheme="https://relish.wang/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
</feed>
